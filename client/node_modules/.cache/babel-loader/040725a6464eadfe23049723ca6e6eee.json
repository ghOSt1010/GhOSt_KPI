{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { Utils as CoreUtils } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport * as FocusedCellUtils from \"../common/internal/focusedCellUtils\";\nimport * as PlatformUtils from \"../common/internal/platformUtils\";\nimport { Utils } from \"../common/utils\";\nimport { Regions } from \"../regions\";\nimport { DragEvents } from \"./dragEvents\";\nimport { Draggable } from \"./draggable\";\n\nvar DragSelectable =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(DragSelectable, _super);\n\n  function DragSelectable() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.didExpandSelectionOnActivate = false;\n\n    _this.handleActivate = function (event) {\n      var _a = _this.props,\n          locateClick = _a.locateClick,\n          selectedRegions = _a.selectedRegions,\n          selectedRegionTransform = _a.selectedRegionTransform;\n\n      if (_this.shouldIgnoreMouseDown(event)) {\n        return false;\n      }\n\n      var region = locateClick(event);\n\n      if (!Regions.isValid(region)) {\n        return false;\n      }\n\n      if (selectedRegionTransform != null) {\n        region = selectedRegionTransform(region, event);\n      }\n\n      var foundIndex = Regions.findMatchingRegion(selectedRegions, region);\n      var matchesExistingSelection = foundIndex !== -1;\n\n      if (matchesExistingSelection && DragEvents.isAdditive(event)) {\n        _this.handleClearSelectionAtIndex(foundIndex); // if we just deselected a selected region, a subsequent drag-move\n        // could reselect it again and *also* clear other selections. that's\n        // quite unintuitive, so ignore subsequent drag-move's.\n\n\n        return false;\n      } // we want to listen to subsequent drag-move's in all following cases,\n      // so this mousedown can be the start of a new selection if desired.\n\n\n      if (matchesExistingSelection) {\n        _this.handleClearAllSelectionsNotAtIndex(foundIndex);\n      } else if (_this.shouldExpandSelection(event)) {\n        _this.handleExpandSelection(region);\n      } else if (_this.shouldAddDisjointSelection(event)) {\n        _this.handleAddDisjointSelection(region);\n      } else {\n        _this.handleReplaceSelection(region);\n      }\n\n      return true;\n    };\n\n    _this.handleDragMove = function (event, coords) {\n      var _a = _this.props,\n          enableMultipleSelection = _a.enableMultipleSelection,\n          focusedCell = _a.focusedCell,\n          locateClick = _a.locateClick,\n          locateDrag = _a.locateDrag,\n          selectedRegions = _a.selectedRegions,\n          selectedRegionTransform = _a.selectedRegionTransform;\n      var region = enableMultipleSelection ? locateDrag(event, coords,\n      /* returnEndOnly? */\n      _this.didExpandSelectionOnActivate) : locateClick(event);\n\n      if (!Regions.isValid(region)) {\n        return;\n      } else if (selectedRegionTransform != null) {\n        region = selectedRegionTransform(region, event, coords);\n      }\n\n      var nextSelectedRegions = _this.didExpandSelectionOnActivate ? _this.expandSelectedRegions(selectedRegions, region, focusedCell) : Regions.update(selectedRegions, region);\n\n      _this.maybeInvokeSelectionCallback(nextSelectedRegions);\n\n      if (!enableMultipleSelection) {\n        // move the focused cell with the selected region\n        var lastIndex = nextSelectedRegions.length - 1;\n        var mostRecentRegion = nextSelectedRegions[lastIndex];\n\n        _this.invokeOnFocusCallbackForRegion(mostRecentRegion, lastIndex);\n      }\n    };\n\n    _this.handleDragEnd = function () {\n      _this.finishInteraction();\n    };\n\n    _this.handleClick = function () {\n      _this.finishInteraction();\n    }; // Boolean checks\n    // ==============\n\n\n    _this.shouldExpandSelection = function (event) {\n      var enableMultipleSelection = _this.props.enableMultipleSelection;\n      return enableMultipleSelection && event.shiftKey;\n    };\n\n    _this.shouldAddDisjointSelection = function (event) {\n      var enableMultipleSelection = _this.props.enableMultipleSelection;\n      return enableMultipleSelection && DragEvents.isAdditive(event);\n    }; // Update logic\n    // ============\n\n\n    _this.handleClearSelectionAtIndex = function (selectedRegionIndex) {\n      var selectedRegions = _this.props.selectedRegions; // remove just the clicked region, leaving other selected regions in place\n\n      var nextSelectedRegions = selectedRegions.slice();\n      nextSelectedRegions.splice(selectedRegionIndex, 1);\n\n      _this.maybeInvokeSelectionCallback(nextSelectedRegions); // if there are still any selections, move the focused cell to the\n      // most recent selection. otherwise, don't update it.\n\n\n      if (nextSelectedRegions.length > 0) {\n        var lastIndex = nextSelectedRegions.length - 1;\n\n        _this.invokeOnFocusCallbackForRegion(nextSelectedRegions[lastIndex], lastIndex);\n      }\n    };\n\n    _this.handleClearAllSelectionsNotAtIndex = function (selectedRegionIndex) {\n      var selectedRegions = _this.props.selectedRegions;\n      var nextSelectedRegion = selectedRegions[selectedRegionIndex];\n\n      _this.maybeInvokeSelectionCallback([nextSelectedRegion]);\n\n      _this.invokeOnFocusCallbackForRegion(nextSelectedRegion, 0);\n    };\n\n    _this.handleExpandSelection = function (region) {\n      var _a = _this.props,\n          focusedCell = _a.focusedCell,\n          selectedRegions = _a.selectedRegions;\n      _this.didExpandSelectionOnActivate = true; // there should be only one selected region after expanding. do not\n      // update the focused cell.\n\n      var nextSelectedRegions = _this.expandSelectedRegions(selectedRegions, region, focusedCell);\n\n      _this.maybeInvokeSelectionCallback(nextSelectedRegions); // move the focused cell into the new region if there were no selections before\n\n\n      if (selectedRegions == null || selectedRegions.length === 0) {\n        _this.invokeOnFocusCallbackForRegion(region);\n      }\n    };\n\n    _this.handleAddDisjointSelection = function (region) {\n      var selectedRegions = _this.props.selectedRegions; // add the new region to the existing selections\n\n      var nextSelectedRegions = Regions.add(selectedRegions, region);\n\n      _this.maybeInvokeSelectionCallback(nextSelectedRegions); // put the focused cell in the new region\n\n\n      _this.invokeOnFocusCallbackForRegion(region, nextSelectedRegions.length - 1);\n    };\n\n    _this.handleReplaceSelection = function (region) {\n      // clear all selections and retain only the new one\n      var nextSelectedRegions = [region];\n\n      _this.maybeInvokeSelectionCallback(nextSelectedRegions); // move the focused cell into the new selection\n\n\n      _this.invokeOnFocusCallbackForRegion(region);\n    };\n\n    _this.invokeOnFocusCallbackForRegion = function (focusRegion, focusSelectionIndex) {\n      if (focusSelectionIndex === void 0) {\n        focusSelectionIndex = 0;\n      }\n\n      var onFocusedCell = _this.props.onFocusedCell;\n      var focusedCellCoords = Regions.getFocusCellCoordinatesFromRegion(focusRegion);\n      onFocusedCell(FocusedCellUtils.toFullCoordinates(focusedCellCoords, focusSelectionIndex));\n    }; // Other\n    // =====\n\n\n    _this.finishInteraction = function () {\n      CoreUtils.safeInvoke(_this.props.onSelectionEnd, _this.props.selectedRegions);\n      _this.didExpandSelectionOnActivate = false;\n      _this.lastEmittedSelectedRegions = null;\n    };\n\n    return _this;\n  }\n\n  DragSelectable.prototype.render = function () {\n    var draggableProps = this.getDraggableProps();\n    return React.createElement(Draggable, tslib_1.__assign({}, draggableProps, {\n      preventDefault: false\n    }), this.props.children);\n  };\n\n  DragSelectable.prototype.getDraggableProps = function () {\n    return this.props.onSelection == null ? {} : {\n      onActivate: this.handleActivate,\n      onClick: this.handleClick,\n      onDragEnd: this.handleDragEnd,\n      onDragMove: this.handleDragMove\n    };\n  };\n\n  DragSelectable.prototype.shouldIgnoreMouseDown = function (event) {\n    var _a = this.props,\n        disabled = _a.disabled,\n        _b = _a.ignoredSelectors,\n        ignoredSelectors = _b === void 0 ? [] : _b;\n    var element = event.target;\n    var isLeftClick = Utils.isLeftClick(event);\n    var isContextMenuTrigger = isLeftClick && event.ctrlKey && PlatformUtils.isMac();\n    var isDisabled = CoreUtils.safeInvokeOrValue(disabled, event);\n    return !isLeftClick || isContextMenuTrigger || isDisabled || ignoredSelectors.some(function (selector) {\n      return element.closest(selector) != null;\n    });\n  }; // Callbacks\n  // =========\n\n\n  DragSelectable.prototype.maybeInvokeSelectionCallback = function (nextSelectedRegions) {\n    var onSelection = this.props.onSelection; // invoke only if the selection changed. this is useful only on\n    // mousemove; there's special handling for mousedown interactions that\n    // target an already-selected region.\n\n    if (this.lastEmittedSelectedRegions == null || !CoreUtils.deepCompareKeys(this.lastEmittedSelectedRegions, nextSelectedRegions)) {\n      onSelection(nextSelectedRegions);\n      this.lastEmittedSelectedRegions = nextSelectedRegions;\n    }\n  };\n  /**\n   * Expands the last-selected region to the new region, and replaces the\n   * last-selected region with the expanded region. If a focused cell is provided,\n   * the focused cell will serve as an anchor for the expansion.\n   */\n\n\n  DragSelectable.prototype.expandSelectedRegions = function (regions, region, focusedCell) {\n    if (regions.length === 0) {\n      return [region];\n    } else if (focusedCell != null) {\n      var expandedRegion = FocusedCellUtils.expandFocusedRegion(focusedCell, region);\n      return Regions.update(regions, expandedRegion);\n    } else {\n      var expandedRegion = Regions.expandRegion(regions[regions.length - 1], region);\n      return Regions.update(regions, expandedRegion);\n    }\n  };\n\n  DragSelectable.defaultProps = {\n    disabled: false,\n    enableMultipleSelection: false,\n    selectedRegions: []\n  };\n  return DragSelectable;\n}(React.PureComponent);\n\nexport { DragSelectable };","map":null,"metadata":{},"sourceType":"module"}