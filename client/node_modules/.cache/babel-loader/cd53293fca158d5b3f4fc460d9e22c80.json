{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { RegionCardinality, Regions } from \"../regions\";\nimport * as Classes from \"./classes\";\nimport { Rect } from \"./rect\";\nimport { Utils } from \"./utils\";\n/**\n * This class manages the sizes of grid cells using arrays of individual row/column sizes.\n */\n\nvar Grid =\n/** @class */\nfunction () {\n  /**\n   * This constructor accumulates the heights and widths in `O(n)`, saving\n   * time in later calculations.\n   *\n   * @param bleed - The number of rows/cols that we expand beyond the\n   *     viewport (on all sides). This helps avoid displaying an empty\n   *     viewport when the user scrolls quickly.\n   */\n  function Grid(rowHeights, columnWidths, bleed, ghostHeight, ghostWidth) {\n    var _this = this;\n\n    if (bleed === void 0) {\n      bleed = Grid.DEFAULT_BLEED;\n    }\n\n    if (ghostHeight === void 0) {\n      ghostHeight = Grid.DEFAULT_GHOST_HEIGHT;\n    }\n\n    if (ghostWidth === void 0) {\n      ghostWidth = Grid.DEFAULT_GHOST_WIDTH;\n    }\n\n    this.getCumulativeWidthBefore = function (index) {\n      return index === 0 ? 0 : _this.getCumulativeWidthAt(index - 1);\n    };\n\n    this.getCumulativeWidthAt = function (index) {\n      if (_this.numCols === 0) {\n        return _this.ghostWidth * index;\n      } else if (index >= _this.numCols) {\n        return _this.cumulativeColumnWidths[_this.numCols - 1] + _this.ghostWidth * (index - _this.numCols + 1);\n      } else {\n        return _this.cumulativeColumnWidths[index];\n      }\n    };\n\n    this.getCumulativeHeightBefore = function (index) {\n      return index === 0 ? 0 : _this.getCumulativeHeightAt(index - 1);\n    };\n\n    this.getCumulativeHeightAt = function (index) {\n      if (_this.numRows === 0) {\n        return _this.ghostHeight * index;\n      } else if (index >= _this.numRows) {\n        return _this.cumulativeRowHeights[_this.numRows - 1] + _this.ghostHeight * (index - _this.numRows + 1);\n      } else {\n        return _this.cumulativeRowHeights[index];\n      }\n    };\n\n    this.columnWidths = columnWidths;\n    this.rowHeights = rowHeights;\n    this.cumulativeColumnWidths = Utils.accumulate(columnWidths);\n    this.cumulativeRowHeights = Utils.accumulate(rowHeights);\n    this.numCols = columnWidths.length;\n    this.numRows = rowHeights.length;\n    this.bleed = bleed;\n    this.ghostHeight = ghostHeight;\n    this.ghostWidth = ghostWidth;\n  }\n  /**\n   * Returns the `Rect` bounds of a cell in scrollpane client space.\n   *\n   * Scrollpane client coordinate space uses the origin of the scrollpane\n   * client (the inside part that you're moving around).\n   *\n   * For example, let's say you're scrolling around a block of 1000 x 1000\n   * cells. Regardless where you've scrolled, the first cell is always at\n   * 0,0 in scrollpane client space. the cell to the right of it is always\n   * at, e.g., 100,0.\n   */\n\n\n  Grid.prototype.getCellRect = function (rowIndex, columnIndex) {\n    var height = this.rowHeights[rowIndex];\n    var top = this.cumulativeRowHeights[rowIndex] - height;\n    var width = this.columnWidths[columnIndex];\n    var left = this.cumulativeColumnWidths[columnIndex] - width;\n    return new Rect(left, top, width, height);\n  };\n  /**\n   * Returns the `Rect` bounds of a cell in scrollpane client space.\n   *\n   * If the cell is beyond the bounds of the user-defined table cells, it is\n   * considered a \"ghost\" cell. If a width/height is not defined for that\n   * row/column, we use the default width/height.\n   */\n\n\n  Grid.prototype.getGhostCellRect = function (rowIndex, columnIndex) {\n    var left = 0;\n    var top = 0;\n    var width = 0;\n    var height = 0;\n\n    if (rowIndex >= this.rowHeights.length) {\n      height = this.ghostHeight;\n      top = this.getHeight() + this.ghostHeight * (rowIndex - this.numRows);\n    } else {\n      height = this.rowHeights[rowIndex];\n      top = this.cumulativeRowHeights[rowIndex] - height;\n    }\n\n    if (columnIndex >= this.columnWidths.length) {\n      width = this.ghostWidth;\n      left = this.getWidth() + this.ghostWidth * (columnIndex - this.numCols);\n    } else {\n      width = this.columnWidths[columnIndex];\n      left = this.cumulativeColumnWidths[columnIndex] - width;\n    }\n\n    return new Rect(left, top, width, height);\n  };\n  /**\n   * Returns the `Rect` with the base coordinate and height of the specified row.\n   */\n\n\n  Grid.prototype.getRowRect = function (rowIndex) {\n    var height = this.rowHeights[rowIndex];\n    var top = this.cumulativeRowHeights[rowIndex] - height;\n    return new Rect(0, top, this.getWidth(), height);\n  };\n  /**\n   * Returns the `Rect` with the base coordinate and width of the specified column.\n   */\n\n\n  Grid.prototype.getColumnRect = function (columnIndex) {\n    var width = this.columnWidths[columnIndex];\n    var left = this.cumulativeColumnWidths[columnIndex] - width;\n    return new Rect(left, 0, width, this.getHeight());\n  };\n  /**\n   * Returns the total width of the entire grid\n   */\n\n\n  Grid.prototype.getWidth = function () {\n    return this.numCols === 0 ? 0 : this.cumulativeColumnWidths[this.numCols - 1];\n  };\n  /**\n   * Returns the total width of the entire grid\n   */\n\n\n  Grid.prototype.getHeight = function () {\n    return this.numRows === 0 ? 0 : this.cumulativeRowHeights[this.numRows - 1];\n  };\n  /**\n   * Returns the `Rect` bounds of entire grid\n   */\n\n\n  Grid.prototype.getRect = function () {\n    return new Rect(0, 0, this.getWidth(), this.getHeight());\n  };\n  /**\n   * Maps each cell that intersects with the given `Rect` argument. The\n   * indices of iteration are extended in both directions by the integer\n   * `bleed` class property, then are clamped between 0 and the number of\n   * rows/columns.\n   *\n   * Uses a binary search for each of the 4 edges of the bounds, resulting\n   * in a runtime of `O(log(rows) + log(cols))` plus the `O(irows * icols)`\n   * iteration of intersecting cells.\n   */\n\n\n  Grid.prototype.mapCellsInRect = function (rect, callback) {\n    var results = [];\n\n    if (rect == null) {\n      return results;\n    }\n\n    var _a = this.getRowIndicesInRect(rect),\n        rowIndexStart = _a.rowIndexStart,\n        rowIndexEnd = _a.rowIndexEnd;\n\n    var _b = this.getColumnIndicesInRect(rect),\n        columnIndexStart = _b.columnIndexStart,\n        columnIndexEnd = _b.columnIndexEnd;\n\n    for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n      for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n        results.push(callback(rowIndex, columnIndex));\n      }\n    }\n\n    return results;\n  };\n  /**\n   * Maps each row that intersects with the given `Rect` argument.\n   *\n   * See Grid.mapCellsInRect for more details.\n   */\n\n\n  Grid.prototype.mapRowsInRect = function (rect, callback) {\n    var results = [];\n\n    if (rect == null) {\n      return results;\n    }\n\n    var _a = this.getRowIndicesInRect(rect),\n        rowIndexStart = _a.rowIndexStart,\n        rowIndexEnd = _a.rowIndexEnd;\n\n    for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n      results.push(callback(rowIndex));\n    }\n\n    return results;\n  };\n  /**\n   * Maps each column that intersects with the given `Rect` argument.\n   *\n   * See Grid.mapCellsInRect for more details.\n   */\n\n\n  Grid.prototype.mapColumnsInRect = function (rect, callback) {\n    var results = [];\n\n    if (rect == null) {\n      return results;\n    }\n\n    var _a = this.getColumnIndicesInRect(rect),\n        columnIndexStart = _a.columnIndexStart,\n        columnIndexEnd = _a.columnIndexEnd;\n\n    for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n      results.push(callback(columnIndex));\n    }\n\n    return results;\n  };\n  /**\n   * Returns the start and end indices of rows that intersect with the given\n   * `Rect` argument.\n   */\n\n\n  Grid.prototype.getRowIndicesInRect = function (rect, includeGhostCells, limit) {\n    if (includeGhostCells === void 0) {\n      includeGhostCells = false;\n    }\n\n    if (limit === void 0) {\n      limit = Grid.DEFAULT_MAX_ROWS;\n    }\n\n    if (rect == null) {\n      return {\n        rowIndexEnd: 0,\n        rowIndexStart: 0\n      };\n    }\n\n    var searchEnd = includeGhostCells ? Math.max(this.numRows, Grid.DEFAULT_MAX_ROWS) : this.numRows;\n\n    var _a = this.getIndicesInInterval(rect.top, rect.top + rect.height, searchEnd, !includeGhostCells, this.getCumulativeHeightAt),\n        start = _a.start,\n        end = _a.end;\n\n    var rowIndexEnd = limit > 0 && end - start > limit ? start + limit : end;\n    return {\n      rowIndexEnd: rowIndexEnd,\n      rowIndexStart: start\n    };\n  };\n  /**\n   * Returns the start and end indices of columns that intersect with the\n   * given `Rect` argument.\n   */\n\n\n  Grid.prototype.getColumnIndicesInRect = function (rect, includeGhostCells, limit) {\n    if (includeGhostCells === void 0) {\n      includeGhostCells = false;\n    }\n\n    if (limit === void 0) {\n      limit = Grid.DEFAULT_MAX_COLUMNS;\n    }\n\n    if (rect == null) {\n      return {\n        columnIndexEnd: 0,\n        columnIndexStart: 0\n      };\n    }\n\n    var searchEnd = includeGhostCells ? Math.max(this.numCols, Grid.DEFAULT_MAX_COLUMNS) : this.numCols;\n\n    var _a = this.getIndicesInInterval(rect.left, rect.left + rect.width, searchEnd, !includeGhostCells, this.getCumulativeWidthAt),\n        start = _a.start,\n        end = _a.end;\n\n    var columnIndexEnd = limit > 0 && end - start > limit ? start + limit : end;\n    return {\n      columnIndexEnd: columnIndexEnd,\n      columnIndexStart: start\n    };\n  };\n\n  Grid.prototype.isGhostIndex = function (rowIndex, columnIndex) {\n    return rowIndex >= this.numRows || columnIndex >= this.numCols;\n  };\n\n  Grid.prototype.isGhostColumn = function (columnIndex) {\n    return columnIndex >= this.numCols;\n  };\n\n  Grid.prototype.getExtremaClasses = function (rowIndex, columnIndex, rowEnd, columnEnd) {\n    if (rowIndex === rowEnd && columnIndex === columnEnd) {\n      return [Classes.TABLE_LAST_IN_COLUMN, Classes.TABLE_LAST_IN_ROW];\n    }\n\n    if (rowIndex === rowEnd) {\n      return [Classes.TABLE_LAST_IN_COLUMN];\n    }\n\n    if (columnIndex === columnEnd) {\n      return [Classes.TABLE_LAST_IN_ROW];\n    }\n\n    return [];\n  };\n\n  Grid.prototype.getRegionStyle = function (region) {\n    var cardinality = Regions.getRegionCardinality(region);\n\n    switch (cardinality) {\n      case RegionCardinality.CELLS:\n        {\n          var _a = region.rows,\n              rowStart = _a[0],\n              rowEnd = _a[1];\n          var _b = region.cols,\n              colStart = _b[0],\n              colEnd = _b[1]; // if the region is outside the bounds of the table, don't display it\n\n          if (this.isGhostIndex(rowStart, colStart) || this.isGhostIndex(rowEnd, colEnd)) {\n            return {\n              display: \"none\"\n            };\n          }\n\n          var cellRect0 = this.getCellRect(rowStart, colStart);\n          var cellRect1 = this.getCellRect(rowEnd, colEnd);\n          var offsetLeft = colStart === 0 ? 0 : 1;\n          var offsetTop = rowStart === 0 ? 0 : 1;\n          var rect = cellRect0.union(cellRect1);\n          rect.height += offsetTop;\n          rect.left -= offsetLeft;\n          rect.width += offsetLeft;\n          rect.top -= offsetTop;\n          return tslib_1.__assign({}, rect.style(), {\n            display: \"block\"\n          });\n        }\n\n      case RegionCardinality.FULL_COLUMNS:\n        {\n          var _c = region.cols,\n              colStart = _c[0],\n              colEnd = _c[1]; // if the region is outside the bounds of the table, don't display it\n\n          if (this.isGhostIndex(0, colStart) || this.isGhostIndex(0, colEnd)) {\n            return {\n              display: \"none\"\n            };\n          }\n\n          var cellRect0 = this.getCellRect(0, colStart);\n          var cellRect1 = this.getCellRect(0, colEnd);\n          var rect = cellRect0.union(cellRect1);\n          var offsetLeft = colStart === 0 ? 0 : 1;\n          return {\n            bottom: 0,\n            display: \"block\",\n            left: rect.left - offsetLeft,\n            top: 0,\n            width: rect.width + offsetLeft\n          };\n        }\n\n      case RegionCardinality.FULL_ROWS:\n        {\n          var _d = region.rows,\n              rowStart = _d[0],\n              rowEnd = _d[1]; // if the region is outside the bounds of the table, don't display it\n\n          if (this.isGhostIndex(rowStart, 0) || this.isGhostIndex(rowEnd, 0)) {\n            return {\n              display: \"none\"\n            };\n          }\n\n          var cellRect0 = this.getCellRect(rowStart, 0);\n          var cellRect1 = this.getCellRect(rowEnd, 0);\n          var rect = cellRect0.union(cellRect1);\n          var offsetTop = rowStart === 0 ? 0 : 1;\n          return {\n            display: \"block\",\n            height: rect.height + offsetTop,\n            left: 0,\n            right: 0,\n            top: rect.top - offsetTop\n          };\n        }\n\n      case RegionCardinality.FULL_TABLE:\n        return {\n          bottom: 0,\n          display: \"block\",\n          left: 0,\n          right: 0,\n          top: 0\n        };\n\n      default:\n        return {\n          display: \"none\"\n        };\n    }\n  };\n\n  Grid.prototype.getIndicesInInterval = function (min, max, count, useEndBleed, lookup) {\n    var start = Utils.binarySearch(min, count - 1, lookup);\n    var end = Utils.binarySearch(max, count - 1, lookup); // correct exact pixel alignment\n\n    if (start >= 0 && min === lookup(start)) {\n      start += 1;\n    } // apply bounded bleeds\n\n\n    start = Math.max(0, start - this.bleed);\n\n    if (useEndBleed) {\n      end = Math.min(count - 1, end + this.bleed);\n    } else {\n      end = Math.min(count - 1, end);\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  Grid.DEFAULT_BLEED = 3;\n  Grid.DEFAULT_MAX_COLUMNS = 50;\n  Grid.DEFAULT_MAX_ROWS = 200;\n  Grid.DEFAULT_GHOST_HEIGHT = 20;\n  Grid.DEFAULT_GHOST_WIDTH = 150;\n  return Grid;\n}();\n\nexport { Grid };","map":null,"metadata":{},"sourceType":"module"}