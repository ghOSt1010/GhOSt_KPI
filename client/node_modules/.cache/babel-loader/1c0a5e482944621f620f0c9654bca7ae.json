{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { DISPLAYNAME_PREFIX, EditableText, Hotkey, Hotkeys, HotkeysTarget, Utils as CoreUtils } from \"@blueprintjs/core\";\nimport * as Classes from \"../common/classes\";\nimport { Draggable } from \"../interactions/draggable\";\nimport { Cell } from \"./cell\";\n\nvar EditableCell =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(EditableCell, _super);\n\n  function EditableCell(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.refHandlers = {\n      cell: function cell(ref) {\n        _this.cellRef = ref;\n      }\n    };\n\n    _this.handleKeyPress = function () {\n      if (_this.state.isEditing || !_this.props.isFocused) {\n        return;\n      } // setting dirty value to empty string because apparently the text field will pick up the key and write it in there\n\n\n      _this.setState({\n        isEditing: true,\n        dirtyValue: \"\",\n        savedValue: _this.state.savedValue\n      });\n    };\n\n    _this.handleEdit = function () {\n      _this.setState({\n        isEditing: true,\n        dirtyValue: _this.state.savedValue\n      });\n    };\n\n    _this.handleCancel = function (value) {\n      // don't strictly need to clear the dirtyValue, but it's better hygiene\n      _this.setState({\n        isEditing: false,\n        dirtyValue: undefined\n      });\n\n      _this.invokeCallback(_this.props.onCancel, value);\n    };\n\n    _this.handleChange = function (value) {\n      _this.setState({\n        dirtyValue: value\n      });\n\n      _this.invokeCallback(_this.props.onChange, value);\n    };\n\n    _this.handleConfirm = function (value) {\n      _this.setState({\n        isEditing: false,\n        savedValue: value,\n        dirtyValue: undefined\n      });\n\n      _this.invokeCallback(_this.props.onConfirm, value);\n    };\n\n    _this.handleCellActivate = function (_event) {\n      return true;\n    };\n\n    _this.handleCellDoubleClick = function (_event) {\n      _this.handleEdit();\n    };\n\n    _this.state = {\n      isEditing: false,\n      savedValue: props.value\n    };\n    return _this;\n  }\n\n  EditableCell.prototype.componentDidMount = function () {\n    this.checkShouldFocus();\n  };\n\n  EditableCell.prototype.componentDidUpdate = function (prevProps) {\n    var didPropsChange = !CoreUtils.shallowCompareKeys(this.props, prevProps, {\n      exclude: [\"style\"]\n    }) || !CoreUtils.deepCompareKeys(this.props, prevProps, [\"style\"]);\n    var value = this.props.value;\n\n    if (didPropsChange && value != null) {\n      this.setState({\n        savedValue: value,\n        dirtyValue: value\n      });\n    }\n\n    this.checkShouldFocus();\n  };\n\n  EditableCell.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    return !CoreUtils.shallowCompareKeys(this.props, nextProps, {\n      exclude: [\"style\"]\n    }) || !CoreUtils.shallowCompareKeys(this.state, nextState) || !CoreUtils.deepCompareKeys(this.props, nextProps, [\"style\"]);\n  };\n\n  EditableCell.prototype.render = function () {\n    var _a;\n\n    var _b = this.props,\n        onCancel = _b.onCancel,\n        onChange = _b.onChange,\n        onConfirm = _b.onConfirm,\n        truncated = _b.truncated,\n        wrapText = _b.wrapText,\n        editableTextProps = _b.editableTextProps,\n        spreadableProps = tslib_1.__rest(_b, [\"onCancel\", \"onChange\", \"onConfirm\", \"truncated\", \"wrapText\", \"editableTextProps\"]);\n\n    var _c = this.state,\n        isEditing = _c.isEditing,\n        dirtyValue = _c.dirtyValue,\n        savedValue = _c.savedValue;\n    var interactive = spreadableProps.interactive || isEditing;\n    var cellContents = null;\n\n    if (isEditing) {\n      var className = editableTextProps ? editableTextProps.className : null;\n      cellContents = React.createElement(EditableText, tslib_1.__assign({}, editableTextProps, {\n        isEditing: true,\n        className: classNames(Classes.TABLE_EDITABLE_TEXT, Classes.TABLE_EDITABLE_NAME, className),\n        intent: spreadableProps.intent,\n        minWidth: null,\n        onCancel: this.handleCancel,\n        onChange: this.handleChange,\n        onConfirm: this.handleConfirm,\n        onEdit: this.handleEdit,\n        placeholder: \"\",\n        selectAllOnFocus: false,\n        value: dirtyValue\n      }));\n    } else {\n      var textClasses = classNames(Classes.TABLE_EDITABLE_TEXT, (_a = {}, _a[Classes.TABLE_TRUNCATED_TEXT] = truncated, _a[Classes.TABLE_NO_WRAP_TEXT] = !wrapText, _a));\n      cellContents = React.createElement(\"div\", {\n        className: textClasses\n      }, savedValue);\n    }\n\n    return React.createElement(Cell, tslib_1.__assign({}, spreadableProps, {\n      wrapText: wrapText,\n      truncated: false,\n      interactive: interactive,\n      cellRef: this.refHandlers.cell,\n      onKeyPress: this.handleKeyPress\n    }), React.createElement(Draggable, {\n      onActivate: this.handleCellActivate,\n      onDoubleClick: this.handleCellDoubleClick,\n      preventDefault: false,\n      stopPropagation: interactive\n    }, cellContents));\n  };\n\n  EditableCell.prototype.renderHotkeys = function () {\n    var tabIndex = this.props.tabIndex;\n    return React.createElement(Hotkeys, {\n      tabIndex: tabIndex\n    }, React.createElement(Hotkey, {\n      key: \"edit-cell\",\n      label: \"Edit the currently focused cell\",\n      group: \"Table\",\n      combo: \"f2\",\n      onKeyDown: this.handleEdit\n    }));\n  };\n\n  EditableCell.prototype.checkShouldFocus = function () {\n    if (this.props.isFocused && !this.state.isEditing) {\n      // don't focus if we're editing -- we'll lose the fact that we're editing\n      this.cellRef.focus();\n    }\n  };\n\n  EditableCell.prototype.invokeCallback = function (callback, value) {\n    // pass through the row and column indices if they were provided as props by the consumer\n    var _a = this.props,\n        rowIndex = _a.rowIndex,\n        columnIndex = _a.columnIndex;\n    CoreUtils.safeInvoke(callback, value, rowIndex, columnIndex);\n  };\n\n  EditableCell.displayName = DISPLAYNAME_PREFIX + \".EditableCell\";\n  EditableCell.defaultProps = {\n    truncated: true,\n    wrapText: false\n  };\n  EditableCell = tslib_1.__decorate([HotkeysTarget], EditableCell);\n  return EditableCell;\n}(React.Component);\n\nexport { EditableCell };","map":null,"metadata":{},"sourceType":"module"}