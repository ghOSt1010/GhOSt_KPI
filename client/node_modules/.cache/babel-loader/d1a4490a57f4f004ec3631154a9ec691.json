{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as Classes from \"./common/classes\";\nimport { Rect } from \"./common/rect\";\nimport { Utils } from \"./common/utils\";\n\nvar Locator =\n/** @class */\nfunction () {\n  function Locator(\n  /* The root table element within which a click is deemed valid and relevant. */\n  tableElement,\n  /* The scrollable element that wraps the cell container. */\n  scrollContainerElement,\n  /* The element containing all body cells in the grid (excluding headers). */\n  cellContainerElement) {\n    var _this = this;\n\n    this.tableElement = tableElement;\n    this.scrollContainerElement = scrollContainerElement;\n    this.cellContainerElement = cellContainerElement;\n\n    this.convertCellIndexToClientX = function (index) {\n      return _this.grid.getCumulativeWidthAt(index);\n    };\n\n    this.convertCellMidpointToClientX = function (index) {\n      var cellLeft = _this.grid.getCumulativeWidthBefore(index);\n\n      var cellRight = _this.grid.getCumulativeWidthAt(index);\n\n      return (cellLeft + cellRight) / 2;\n    };\n\n    this.convertCellIndexToClientY = function (index) {\n      return _this.grid.getCumulativeHeightAt(index);\n    };\n\n    this.convertCellMidpointToClientY = function (index) {\n      var cellTop = _this.grid.getCumulativeHeightBefore(index);\n\n      var cellBottom = _this.grid.getCumulativeHeightAt(index);\n\n      return (cellTop + cellBottom) / 2;\n    };\n\n    this.toGridX = function (clientX) {\n      var gridOffsetFromPageLeft = _this.cellContainerElement.getBoundingClientRect().left;\n\n      var scrollOffsetFromGridLeft = _this.scrollContainerElement.scrollLeft;\n      var cursorOffsetFromGridLeft = clientX - (gridOffsetFromPageLeft + scrollOffsetFromGridLeft);\n\n      var isCursorWithinFrozenColumns = _this.numFrozenColumns != null && _this.numFrozenColumns > 0 && cursorOffsetFromGridLeft <= _this.grid.getCumulativeWidthBefore(_this.numFrozenColumns); // the frozen-columnÂ region doesn't scroll, so ignore the scroll distance in that case\n\n\n      return isCursorWithinFrozenColumns ? cursorOffsetFromGridLeft : cursorOffsetFromGridLeft + scrollOffsetFromGridLeft;\n    };\n\n    this.toGridY = function (clientY) {\n      var gridOffsetFromPageTop = _this.cellContainerElement.getBoundingClientRect().top;\n\n      var scrollOffsetFromGridTop = _this.scrollContainerElement.scrollTop;\n      var cursorOffsetFromGridTop = clientY - (gridOffsetFromPageTop + scrollOffsetFromGridTop);\n\n      var isCursorWithinFrozenRows = _this.numFrozenRows != null && _this.numFrozenRows > 0 && cursorOffsetFromGridTop <= _this.grid.getCumulativeHeightBefore(_this.numFrozenRows);\n\n      return isCursorWithinFrozenRows ? cursorOffsetFromGridTop : cursorOffsetFromGridTop + scrollOffsetFromGridTop;\n    };\n\n    this.numFrozenRows = 0;\n    this.numFrozenColumns = 0;\n  } // Setters\n  // =======\n\n\n  Locator.prototype.setGrid = function (grid) {\n    this.grid = grid;\n    return this;\n  };\n\n  Locator.prototype.setNumFrozenRows = function (numFrozenRows) {\n    this.numFrozenRows = numFrozenRows;\n    return this;\n  };\n\n  Locator.prototype.setNumFrozenColumns = function (numFrozenColumns) {\n    this.numFrozenColumns = numFrozenColumns;\n    return this;\n  }; // Getters\n  // =======\n\n\n  Locator.prototype.getViewportRect = function () {\n    return new Rect(this.scrollContainerElement.scrollLeft, this.scrollContainerElement.scrollTop, this.scrollContainerElement.clientWidth, this.scrollContainerElement.clientHeight);\n  };\n\n  Locator.prototype.getWidestVisibleCellInColumn = function (columnIndex) {\n    var columnCellSelector = this.getColumnCellSelector(columnIndex);\n    var columnHeaderAndBodyCells = this.tableElement.querySelectorAll(columnCellSelector);\n    var maxWidth = 0;\n\n    for (var i = 0; i < columnHeaderAndBodyCells.length; i++) {\n      var contentWidth = Utils.measureElementTextContent(columnHeaderAndBodyCells.item(i)).width;\n      var cellWidth = Math.ceil(contentWidth) + Locator.CELL_HORIZONTAL_PADDING * 2;\n\n      if (cellWidth > maxWidth) {\n        maxWidth = cellWidth;\n      }\n    }\n\n    return maxWidth;\n  };\n\n  Locator.prototype.getTallestVisibleCellInColumn = function (columnIndex) {\n    // consider only body cells, hence the extra Classes.TABLE_CELL specificity\n    var columnCellSelector = this.getColumnCellSelector(columnIndex);\n    var columnBodyCells = this.tableElement.querySelectorAll(columnCellSelector + \".\" + Classes.TABLE_CELL);\n    var maxHeight = 0;\n\n    for (var i = 0; i < columnBodyCells.length; i++) {\n      var cell = columnBodyCells.item(i);\n      var cellValue = cell.querySelector(\".\" + Classes.TABLE_TRUNCATED_VALUE);\n      var cellTruncatedFormatText = cell.querySelector(\".\" + Classes.TABLE_TRUNCATED_FORMAT_TEXT);\n      var cellTruncatedText = cell.querySelector(\".\" + Classes.TABLE_TRUNCATED_TEXT);\n      var height = 0;\n\n      if (cellValue != null) {\n        height = cellValue.scrollHeight;\n      } else if (cellTruncatedFormatText != null) {\n        height = cellTruncatedFormatText.scrollHeight;\n      } else if (cellTruncatedText != null) {\n        height = cellTruncatedText.scrollHeight;\n      } else {\n        // it's not anything we recognize, just use the current height of the cell\n        height = cell.scrollHeight;\n      }\n\n      if (height > maxHeight) {\n        maxHeight = height;\n      }\n    }\n\n    return maxHeight;\n  }; // Converters\n  // ==========\n\n\n  Locator.prototype.convertPointToColumn = function (clientX, useMidpoint) {\n    var tableRect = this.getTableRect();\n\n    if (!tableRect.containsX(clientX)) {\n      return -1;\n    }\n\n    var gridX = this.toGridX(clientX);\n    var limit = useMidpoint ? this.grid.numCols : this.grid.numCols - 1;\n    var lookupFn = useMidpoint ? this.convertCellMidpointToClientX : this.convertCellIndexToClientX;\n    return Utils.binarySearch(gridX, limit, lookupFn);\n  };\n\n  Locator.prototype.convertPointToRow = function (clientY, useMidpoint) {\n    var tableRect = this.getTableRect();\n\n    if (!tableRect.containsY(clientY)) {\n      return -1;\n    }\n\n    var gridY = this.toGridY(clientY);\n    var limit = useMidpoint ? this.grid.numRows : this.grid.numRows - 1;\n    var lookupFn = useMidpoint ? this.convertCellMidpointToClientY : this.convertCellIndexToClientY;\n    return Utils.binarySearch(gridY, limit, lookupFn);\n  };\n\n  Locator.prototype.convertPointToCell = function (clientX, clientY) {\n    var gridX = this.toGridX(clientX);\n    var gridY = this.toGridY(clientY);\n    var col = Utils.binarySearch(gridX, this.grid.numCols - 1, this.convertCellIndexToClientX);\n    var row = Utils.binarySearch(gridY, this.grid.numRows - 1, this.convertCellIndexToClientY);\n    return {\n      col: col,\n      row: row\n    };\n  }; // Private helpers\n  // ===============\n\n\n  Locator.prototype.getColumnCellSelector = function (columnIndex) {\n    // measure frozen columns in the LEFT quadrant; otherwise, they might\n    // have been scrolled out of view, leading to wonky measurements (#1561)\n    var isFrozenColumnIndex = columnIndex < this.numFrozenColumns;\n    var quadrantClass = isFrozenColumnIndex ? Classes.TABLE_QUADRANT_LEFT : Classes.TABLE_QUADRANT_MAIN;\n    var cellClass = Classes.columnCellIndexClass(columnIndex);\n    return \".\" + quadrantClass + \" .\" + cellClass;\n  };\n\n  Locator.prototype.getTableRect = function () {\n    return Rect.wrap(this.tableElement.getBoundingClientRect());\n  };\n\n  Locator.CELL_HORIZONTAL_PADDING = 10;\n  return Locator;\n}();\n\nexport { Locator };","map":null,"metadata":{},"sourceType":"module"}