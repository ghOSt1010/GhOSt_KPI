{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Utils } from \"@blueprintjs/core\";\nimport { requestIdleCallback } from \"./requestIdleCallback\";\n/**\n * This class helps batch updates to large lists.\n *\n * For example, if your React component has many children, updating them all at\n * once may cause jank when reconciling the DOM. This class helps you update\n * only a few children per frame.\n *\n * A typical usage would be:\n *\n * ```tsx\n * public renderChildren = (allChildrenKeys: string[]) => {\n *\n *     batcher.startNewBatch();\n *\n *     allChildrenKeys.forEach((prop1: string, index: number) => {\n *         batcher.addArgsToBatch(prop1, \"prop2\", index);\n *     });\n *\n *     batcher.removeOldAddNew((prop1: string, prop2: string, other: number) => {\n *         return <Child prop1={prop1} prop2={prop2} other={other} />;\n *     });\n *\n *     if (!batcher.isDone()) {\n *         batcher.idleCallback(this.forceUpdate());\n *     }\n *\n *     const currentChildren = batcher.getList();\n *     return currentChildren;\n * }\n *\n * ```\n */\n\nvar Batcher =\n/** @class */\nfunction () {\n  function Batcher() {\n    var _this = this;\n\n    this.currentObjects = {};\n    this.oldObjects = {};\n    this.batchArgs = {};\n    this.done = true;\n\n    this.handleIdleCallback = function () {\n      var callback = _this.callback;\n      delete _this.callback;\n      Utils.safeInvoke(callback);\n    };\n\n    this.mapCurrentObjectKey = function (key) {\n      return _this.currentObjects[key];\n    };\n  }\n  /**\n   * Resets the \"batch\" and \"current\" sets. This essentially clears the cache\n   * and prevents accidental re-use of \"current\" objects.\n   */\n\n\n  Batcher.prototype.reset = function () {\n    this.batchArgs = {};\n    this.oldObjects = this.currentObjects;\n    this.currentObjects = {};\n  };\n  /**\n   * Starts a new \"batch\" argument set\n   */\n\n\n  Batcher.prototype.startNewBatch = function () {\n    this.batchArgs = {};\n  };\n  /**\n   * Stores the variadic arguments to be later batched together.\n   *\n   * The arguments must be simple stringifyable objects.\n   */\n\n\n  Batcher.prototype.addArgsToBatch = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    this.batchArgs[this.getKey(args)] = args;\n  };\n  /**\n   * Compares the set of \"batch\" arguments to the \"current\" set. Creates any\n   * new objects using the callback as a factory. Removes old objects.\n   *\n   * Arguments that are in the \"current\" set but were not part of the last\n   * \"batch\" set are considered candidates for removal. Similarly, Arguments\n   * that are part of the \"batch\" set but not the \"current\" set are candidates\n   * for addition.\n   *\n   * The number of objects added and removed may be limited with the\n   * `...Limit` parameters.\n   *\n   * Finally, the batcher determines if the batching is complete if the\n   * \"current\" arguments match the \"batch\" arguments.\n   */\n\n\n  Batcher.prototype.removeOldAddNew = function (callback, addNewLimit, removeOldLimit, updateLimit) {\n    var _this = this;\n\n    if (addNewLimit === void 0) {\n      addNewLimit = Batcher.DEFAULT_ADD_LIMIT;\n    }\n\n    if (removeOldLimit === void 0) {\n      removeOldLimit = Batcher.DEFAULT_REMOVE_LIMIT;\n    }\n\n    if (updateLimit === void 0) {\n      updateLimit = Batcher.DEFAULT_UPDATE_LIMIT;\n    } // remove old\n\n\n    var keysToRemove = this.setKeysDifference(this.currentObjects, this.batchArgs, removeOldLimit);\n    keysToRemove.forEach(function (key) {\n      return delete _this.currentObjects[key];\n    }); // remove ALL old objects not in batch\n\n    var keysToRemoveOld = this.setKeysDifference(this.oldObjects, this.batchArgs, -1);\n    keysToRemoveOld.forEach(function (key) {\n      return delete _this.oldObjects[key];\n    }); // copy ALL old objects into current objects if not defined\n\n    var keysToShallowCopy = Object.keys(this.oldObjects);\n    keysToShallowCopy.forEach(function (key) {\n      if (_this.currentObjects[key] == null) {\n        _this.currentObjects[key] = _this.oldObjects[key];\n      }\n    }); // update old objects with factory\n\n    var keysToUpdate = this.setKeysIntersection(this.oldObjects, this.currentObjects, updateLimit);\n    keysToUpdate.forEach(function (key) {\n      delete _this.oldObjects[key];\n      _this.currentObjects[key] = callback.apply(undefined, _this.batchArgs[key]);\n    }); // add new objects with factory\n\n    var keysToAdd = this.setKeysDifference(this.batchArgs, this.currentObjects, addNewLimit);\n    keysToAdd.forEach(function (key) {\n      return _this.currentObjects[key] = callback.apply(undefined, _this.batchArgs[key]);\n    }); // set `done` to true if sets match exactly after add/remove and there\n    // are no \"old objects\" remaining\n\n    this.done = this.setHasSameKeys(this.batchArgs, this.currentObjects) && Object.keys(this.oldObjects).length === 0;\n  };\n  /**\n   * Returns true if the \"current\" set matches the \"batch\" set.\n   */\n\n\n  Batcher.prototype.isDone = function () {\n    return this.done;\n  };\n  /**\n   * Returns all the objects in the \"current\" set.\n   */\n\n\n  Batcher.prototype.getList = function () {\n    return Object.keys(this.currentObjects).map(this.mapCurrentObjectKey);\n  };\n  /**\n   * Registers a callback to be invoked on the next idle frame. If a callback\n   * has already been registered, we do not register a new one.\n   */\n\n\n  Batcher.prototype.idleCallback = function (callback) {\n    if (!this.callback) {\n      this.callback = callback;\n      requestIdleCallback(this.handleIdleCallback);\n    }\n  };\n\n  Batcher.prototype.cancelOutstandingCallback = function () {\n    delete this.callback;\n  };\n  /**\n   * Forcibly overwrites the current list of batched objects. Not recommended\n   * for normal usage.\n   */\n\n\n  Batcher.prototype.setList = function (objectsArgs, objects) {\n    var _this = this;\n\n    this.reset();\n    objectsArgs.forEach(function (args, i) {\n      _this.addArgsToBatch.apply(_this, args);\n\n      _this.currentObjects[_this.getKey(args)] = objects[i];\n    });\n    this.done = true;\n  };\n\n  Batcher.prototype.getKey = function (args) {\n    return args.join(Batcher.ARG_DELIMITER);\n  };\n\n  Batcher.prototype.setKeysDifference = function (a, b, limit) {\n    return this.setKeysOperation(a, b, \"difference\", limit);\n  };\n\n  Batcher.prototype.setKeysIntersection = function (a, b, limit) {\n    return this.setKeysOperation(a, b, \"intersect\", limit);\n  };\n  /**\n   * Compares the keys of A from B -- and performs an \"intersection\" or\n   * \"difference\" operation on the keys.\n   *\n   * Note that the order of operands A and B matters for the \"difference\"\n   * operation.\n   *\n   * Returns an array of at most `limit` keys.\n   */\n\n\n  Batcher.prototype.setKeysOperation = function (a, b, operation, limit) {\n    var result = [];\n    var aKeys = Object.keys(a);\n\n    for (var i = 0; i < aKeys.length && (limit < 0 || result.length < limit); i++) {\n      var key = aKeys[i];\n\n      if (operation === \"difference\" && a[key] && !b[key] || operation === \"intersect\" && a[key] && b[key]) {\n        result.push(key);\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Returns true of objects `a` and `b` have exactly the same keys.\n   */\n\n\n  Batcher.prototype.setHasSameKeys = function (a, b) {\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n\n    for (var _i = 0, aKeys_1 = aKeys; _i < aKeys_1.length; _i++) {\n      var aKey = aKeys_1[_i];\n\n      if (b[aKey] === undefined) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Batcher.DEFAULT_ADD_LIMIT = 20;\n  Batcher.DEFAULT_UPDATE_LIMIT = 20;\n  Batcher.DEFAULT_REMOVE_LIMIT = 20;\n  Batcher.ARG_DELIMITER = \"|\";\n  return Batcher;\n}();\n\nexport { Batcher };","map":null,"metadata":{},"sourceType":"module"}