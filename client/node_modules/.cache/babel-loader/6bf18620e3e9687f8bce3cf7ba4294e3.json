{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { AbstractComponent2, DISPLAYNAME_PREFIX, Hotkey, Hotkeys, HotkeysTarget, Utils as CoreUtils } from \"@blueprintjs/core\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { Column } from \"./column\";\nimport * as Classes from \"./common/classes\";\nimport { Clipboard } from \"./common/clipboard\";\nimport { columnInteractionBarContextTypes } from \"./common/context\";\nimport { Direction } from \"./common/direction\";\nimport * as Errors from \"./common/errors\";\nimport { Grid } from \"./common/grid\";\nimport * as FocusedCellUtils from \"./common/internal/focusedCellUtils\";\nimport * as ScrollUtils from \"./common/internal/scrollUtils\";\nimport * as SelectionUtils from \"./common/internal/selectionUtils\";\nimport { Rect } from \"./common/rect\";\nimport { RenderMode } from \"./common/renderMode\";\nimport { Utils } from \"./common/utils\";\nimport { ColumnHeader } from \"./headers/columnHeader\";\nimport { ColumnHeaderCell } from \"./headers/columnHeaderCell\";\nimport { renderDefaultRowHeader, RowHeader } from \"./headers/rowHeader\";\nimport { ResizeSensor } from \"./interactions/resizeSensor\";\nimport { GuideLayer } from \"./layers/guides\";\nimport { RegionLayer } from \"./layers/regions\";\nimport { Locator } from \"./locator\";\nimport { QuadrantType } from \"./quadrants/tableQuadrant\";\nimport { TableQuadrantStack } from \"./quadrants/tableQuadrantStack\";\nimport { ColumnLoadingOption, RegionCardinality, Regions, SelectionModes, TableLoadingOption } from \"./regions\";\nimport { TableBody } from \"./tableBody\";\n\nvar Table =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Table, _super);\n\n  function Table(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.refHandlers = {\n      cellContainer: function cellContainer(ref) {\n        return _this.cellContainerElement = ref;\n      },\n      columnHeader: function columnHeader(ref) {\n        return _this.columnHeaderElement = ref;\n      },\n      quadrantStack: function quadrantStack(ref) {\n        return _this.quadrantStackInstance = ref;\n      },\n      rootTable: function rootTable(ref) {\n        return _this.rootTableElement = ref;\n      },\n      rowHeader: function rowHeader(ref) {\n        return _this.rowHeaderElement = ref;\n      },\n      scrollContainer: function scrollContainer(ref) {\n        return _this.scrollContainerElement = ref;\n      }\n    };\n    /*\n     * This value is set to `true` when all cells finish mounting for the first\n     * time. It serves as a signal that we can switch to batch rendering.\n     */\n\n    _this.didCompletelyMount = false; // Selection resize\n    // ----------------\n\n    _this.handleSelectionResizeUp = function (e) {\n      return _this.handleSelectionResize(e, Direction.UP);\n    };\n\n    _this.handleSelectionResizeDown = function (e) {\n      return _this.handleSelectionResize(e, Direction.DOWN);\n    };\n\n    _this.handleSelectionResizeLeft = function (e) {\n      return _this.handleSelectionResize(e, Direction.LEFT);\n    };\n\n    _this.handleSelectionResizeRight = function (e) {\n      return _this.handleSelectionResize(e, Direction.RIGHT);\n    };\n\n    _this.handleSelectionResize = function (e, direction) {\n      e.preventDefault();\n      e.stopPropagation();\n      var _a = _this.state,\n          focusedCell = _a.focusedCell,\n          selectedRegions = _a.selectedRegions;\n\n      if (selectedRegions.length === 0) {\n        return;\n      }\n\n      var index = FocusedCellUtils.getFocusedOrLastSelectedIndex(selectedRegions, focusedCell);\n      var region = selectedRegions[index];\n      var nextRegion = SelectionUtils.resizeRegion(region, direction, focusedCell);\n\n      _this.updateSelectedRegionAtIndex(nextRegion, index);\n    };\n\n    _this.handleCopy = function (e) {\n      var _a = _this.props,\n          getCellClipboardData = _a.getCellClipboardData,\n          onCopy = _a.onCopy;\n      var selectedRegions = _this.state.selectedRegions;\n\n      if (getCellClipboardData == null) {\n        return;\n      } // prevent \"real\" copy from being called\n\n\n      e.preventDefault();\n      e.stopPropagation();\n      var cells = Regions.enumerateUniqueCells(selectedRegions, _this.grid.numRows, _this.grid.numCols);\n      var sparse = Regions.sparseMapCells(cells, getCellClipboardData);\n\n      if (sparse != null) {\n        var success = Clipboard.copyCells(sparse);\n        CoreUtils.safeInvoke(onCopy, success);\n      }\n    };\n\n    _this.renderMenu = function (refHandler) {\n      var _a;\n\n      var classes = classNames(Classes.TABLE_MENU, (_a = {}, _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(_this.props, RegionCardinality.FULL_TABLE), _a));\n      return React.createElement(\"div\", {\n        className: classes,\n        ref: refHandler,\n        onMouseDown: _this.handleMenuMouseDown\n      }, _this.maybeRenderRegions(_this.styleMenuRegion));\n    };\n\n    _this.handleMenuMouseDown = function (e) {\n      // the shift+click interaction expands the region from the focused cell.\n      // thus, if shift is pressed we shouldn't move the focused cell.\n      _this.selectAll(!e.shiftKey);\n    };\n\n    _this.selectAll = function (shouldUpdateFocusedCell) {\n      var selectionHandler = _this.getEnabledSelectionHandler(RegionCardinality.FULL_TABLE); // clicking on upper left hand corner sets selection to \"all\"\n      // regardless of current selection state (clicking twice does not deselect table)\n\n\n      selectionHandler([Regions.table()]);\n\n      if (shouldUpdateFocusedCell) {\n        var newFocusedCellCoordinates = Regions.getFocusCellCoordinatesFromRegion(Regions.table());\n\n        _this.handleFocus(FocusedCellUtils.toFullCoordinates(newFocusedCellCoordinates));\n      }\n    };\n\n    _this.handleSelectAllHotkey = function (e) {\n      // prevent \"real\" select all from happening as well\n      e.preventDefault();\n      e.stopPropagation(); // selecting-all via the keyboard should not move the focused cell.\n\n      _this.selectAll(false);\n    };\n\n    _this.columnHeaderCellRenderer = function (columnIndex) {\n      var props = _this.getColumnProps(columnIndex);\n\n      if (props === undefined) {\n        return null;\n      }\n\n      var id = props.id,\n          loadingOptions = props.loadingOptions,\n          cellRenderer = props.cellRenderer,\n          columnHeaderCellRenderer = props.columnHeaderCellRenderer,\n          spreadableProps = tslib_1.__rest(props, [\"id\", \"loadingOptions\", \"cellRenderer\", \"columnHeaderCellRenderer\"]);\n\n      var columnLoading = _this.hasLoadingOption(loadingOptions, ColumnLoadingOption.HEADER);\n\n      if (columnHeaderCellRenderer != null) {\n        var columnHeaderCell = columnHeaderCellRenderer(columnIndex);\n        var columnHeaderCellLoading = columnHeaderCell.props.loading;\n        var columnHeaderCellProps = {\n          loading: columnHeaderCellLoading != null ? columnHeaderCellLoading : columnLoading\n        };\n        return React.cloneElement(columnHeaderCell, columnHeaderCellProps);\n      }\n\n      var baseProps = tslib_1.__assign({\n        index: columnIndex,\n        loading: columnLoading\n      }, spreadableProps);\n\n      if (props.name != null) {\n        return React.createElement(ColumnHeaderCell, tslib_1.__assign({}, baseProps));\n      } else {\n        return React.createElement(ColumnHeaderCell, tslib_1.__assign({}, baseProps, {\n          name: Utils.toBase26Alpha(columnIndex)\n        }));\n      }\n    };\n\n    _this.renderColumnHeader = function (refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly) {\n      var _a;\n\n      if (showFrozenColumnsOnly === void 0) {\n        showFrozenColumnsOnly = false;\n      }\n\n      var _b = _this.state,\n          focusedCell = _b.focusedCell,\n          selectedRegions = _b.selectedRegions,\n          viewportRect = _b.viewportRect;\n      var _c = _this.props,\n          enableMultipleSelection = _c.enableMultipleSelection,\n          enableGhostCells = _c.enableGhostCells,\n          enableColumnReordering = _c.enableColumnReordering,\n          enableColumnResizing = _c.enableColumnResizing,\n          loadingOptions = _c.loadingOptions,\n          maxColumnWidth = _c.maxColumnWidth,\n          minColumnWidth = _c.minColumnWidth,\n          selectedRegionTransform = _c.selectedRegionTransform;\n      var classes = classNames(Classes.TABLE_COLUMN_HEADERS, (_a = {}, _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(_this.props, RegionCardinality.FULL_COLUMNS), _a));\n\n      var columnIndices = _this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells);\n\n      var columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart;\n      var columnIndexEnd = showFrozenColumnsOnly ? _this.getMaxFrozenColumnIndex() : columnIndices.columnIndexEnd;\n      return React.createElement(\"div\", {\n        className: classes\n      }, React.createElement(ColumnHeader, {\n        enableMultipleSelection: enableMultipleSelection,\n        cellRenderer: _this.columnHeaderCellRenderer,\n        focusedCell: focusedCell,\n        grid: _this.grid,\n        isReorderable: enableColumnReordering,\n        isResizable: enableColumnResizing,\n        loading: _this.hasLoadingOption(loadingOptions, TableLoadingOption.COLUMN_HEADERS),\n        locator: _this.locator,\n        maxColumnWidth: maxColumnWidth,\n        measurableElementRef: refHandler,\n        minColumnWidth: minColumnWidth,\n        onColumnWidthChanged: _this.handleColumnWidthChanged,\n        onFocusedCell: _this.handleFocus,\n        onLayoutLock: _this.handleLayoutLock,\n        onReordered: _this.handleColumnsReordered,\n        onReordering: reorderingHandler,\n        onResizeGuide: resizeHandler,\n        onSelection: _this.getEnabledSelectionHandler(RegionCardinality.FULL_COLUMNS),\n        selectedRegions: selectedRegions,\n        selectedRegionTransform: selectedRegionTransform,\n        columnIndexStart: columnIndexStart,\n        columnIndexEnd: columnIndexEnd\n      }, _this.props.children), _this.maybeRenderRegions(_this.styleColumnHeaderRegion));\n    };\n\n    _this.renderRowHeader = function (refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly) {\n      var _a;\n\n      if (showFrozenRowsOnly === void 0) {\n        showFrozenRowsOnly = false;\n      }\n\n      var _b = _this.state,\n          focusedCell = _b.focusedCell,\n          selectedRegions = _b.selectedRegions,\n          viewportRect = _b.viewportRect;\n      var _c = _this.props,\n          enableMultipleSelection = _c.enableMultipleSelection,\n          enableGhostCells = _c.enableGhostCells,\n          enableRowReordering = _c.enableRowReordering,\n          enableRowResizing = _c.enableRowResizing,\n          loadingOptions = _c.loadingOptions,\n          maxRowHeight = _c.maxRowHeight,\n          minRowHeight = _c.minRowHeight,\n          rowHeaderCellRenderer = _c.rowHeaderCellRenderer,\n          selectedRegionTransform = _c.selectedRegionTransform;\n      var classes = classNames(Classes.TABLE_ROW_HEADERS, (_a = {}, _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(_this.props, RegionCardinality.FULL_ROWS), _a));\n\n      var rowIndices = _this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);\n\n      var rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart;\n      var rowIndexEnd = showFrozenRowsOnly ? _this.getMaxFrozenRowIndex() : rowIndices.rowIndexEnd;\n      return React.createElement(\"div\", {\n        className: classes,\n        ref: refHandler\n      }, React.createElement(RowHeader, {\n        enableMultipleSelection: enableMultipleSelection,\n        focusedCell: focusedCell,\n        grid: _this.grid,\n        locator: _this.locator,\n        isReorderable: enableRowReordering,\n        isResizable: enableRowResizing,\n        loading: _this.hasLoadingOption(loadingOptions, TableLoadingOption.ROW_HEADERS),\n        maxRowHeight: maxRowHeight,\n        minRowHeight: minRowHeight,\n        onFocusedCell: _this.handleFocus,\n        onLayoutLock: _this.handleLayoutLock,\n        onResizeGuide: resizeHandler,\n        onReordered: _this.handleRowsReordered,\n        onReordering: reorderingHandler,\n        onRowHeightChanged: _this.handleRowHeightChanged,\n        onSelection: _this.getEnabledSelectionHandler(RegionCardinality.FULL_ROWS),\n        rowHeaderCellRenderer: rowHeaderCellRenderer,\n        selectedRegions: selectedRegions,\n        selectedRegionTransform: selectedRegionTransform,\n        rowIndexStart: rowIndexStart,\n        rowIndexEnd: rowIndexEnd\n      }), _this.maybeRenderRegions(_this.styleRowHeaderRegion));\n    };\n\n    _this.bodyCellRenderer = function (rowIndex, columnIndex) {\n      var columnProps = _this.getColumnProps(columnIndex);\n\n      if (columnProps === undefined) {\n        return null;\n      }\n\n      var id = columnProps.id,\n          loadingOptions = columnProps.loadingOptions,\n          cellRenderer = columnProps.cellRenderer,\n          columnHeaderCellRenderer = columnProps.columnHeaderCellRenderer,\n          name = columnProps.name,\n          nameRenderer = columnProps.nameRenderer,\n          restColumnProps = tslib_1.__rest(columnProps, [\"id\", \"loadingOptions\", \"cellRenderer\", \"columnHeaderCellRenderer\", \"name\", \"nameRenderer\"]);\n\n      var cell = cellRenderer(rowIndex, columnIndex);\n      var _a = cell.props.loading,\n          loading = _a === void 0 ? _this.hasLoadingOption(loadingOptions, ColumnLoadingOption.CELLS) : _a;\n\n      var cellProps = tslib_1.__assign({}, restColumnProps, {\n        loading: loading\n      });\n\n      return React.cloneElement(cell, cellProps);\n    };\n\n    _this.renderBody = function (quadrantType, showFrozenRowsOnly, showFrozenColumnsOnly) {\n      if (showFrozenRowsOnly === void 0) {\n        showFrozenRowsOnly = false;\n      }\n\n      if (showFrozenColumnsOnly === void 0) {\n        showFrozenColumnsOnly = false;\n      }\n\n      var _a = _this.state,\n          focusedCell = _a.focusedCell,\n          numFrozenColumns = _a.numFrozenColumnsClamped,\n          numFrozenRows = _a.numFrozenRowsClamped,\n          selectedRegions = _a.selectedRegions,\n          viewportRect = _a.viewportRect;\n      var _b = _this.props,\n          enableMultipleSelection = _b.enableMultipleSelection,\n          enableGhostCells = _b.enableGhostCells,\n          loadingOptions = _b.loadingOptions,\n          bodyContextMenuRenderer = _b.bodyContextMenuRenderer,\n          selectedRegionTransform = _b.selectedRegionTransform;\n\n      var rowIndices = _this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);\n\n      var columnIndices = _this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells); // start beyond the frozen area if rendering unrelated quadrants, so we\n      // don't render duplicate cells underneath the frozen ones.\n\n\n      var columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart + numFrozenColumns;\n      var rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart + numFrozenRows; // if rendering frozen rows/columns, subtract one to convert to\n      // 0-indexing. if the 1-indexed value is 0, this sets the end index\n      // to -1, which avoids rendering absent frozen rows/columns at all.\n\n      var columnIndexEnd = showFrozenColumnsOnly ? numFrozenColumns - 1 : columnIndices.columnIndexEnd;\n      var rowIndexEnd = showFrozenRowsOnly ? numFrozenRows - 1 : rowIndices.rowIndexEnd; // the main quadrant contains all cells in the table, so listen only to that quadrant\n\n      var onCompleteRender = quadrantType === QuadrantType.MAIN ? _this.handleCompleteRender : undefined;\n      return React.createElement(\"div\", null, React.createElement(TableBody, {\n        enableMultipleSelection: enableMultipleSelection,\n        cellRenderer: _this.bodyCellRenderer,\n        focusedCell: focusedCell,\n        grid: _this.grid,\n        loading: _this.hasLoadingOption(loadingOptions, TableLoadingOption.CELLS),\n        locator: _this.locator,\n        onCompleteRender: onCompleteRender,\n        onFocusedCell: _this.handleFocus,\n        onSelection: _this.getEnabledSelectionHandler(RegionCardinality.CELLS),\n        bodyContextMenuRenderer: bodyContextMenuRenderer,\n        renderMode: _this.getNormalizedRenderMode(),\n        selectedRegions: selectedRegions,\n        selectedRegionTransform: selectedRegionTransform,\n        viewportRect: viewportRect,\n        columnIndexStart: columnIndexStart,\n        columnIndexEnd: columnIndexEnd,\n        rowIndexStart: rowIndexStart,\n        rowIndexEnd: rowIndexEnd,\n        numFrozenColumns: showFrozenColumnsOnly ? numFrozenColumns : undefined,\n        numFrozenRows: showFrozenRowsOnly ? numFrozenRows : undefined\n      }), _this.maybeRenderRegions(_this.styleBodyRegion, quadrantType));\n    };\n\n    _this.handleCompleteRender = function () {\n      // the first onCompleteRender is triggered before the viewportRect is\n      // defined and the second after the viewportRect has been set. the cells\n      // will only actually render once the viewportRect is defined though, so\n      // we defer invoking onCompleteRender until that check passes.\n      if (_this.state.viewportRect != null) {\n        CoreUtils.safeInvoke(_this.props.onCompleteRender);\n        _this.didCompletelyMount = true;\n      }\n    };\n\n    _this.handleFocusMoveLeft = function (e) {\n      return _this.handleFocusMove(e, \"left\");\n    };\n\n    _this.handleFocusMoveLeftInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"left\");\n    };\n\n    _this.handleFocusMoveRight = function (e) {\n      return _this.handleFocusMove(e, \"right\");\n    };\n\n    _this.handleFocusMoveRightInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"right\");\n    };\n\n    _this.handleFocusMoveUp = function (e) {\n      return _this.handleFocusMove(e, \"up\");\n    };\n\n    _this.handleFocusMoveUpInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"up\");\n    };\n\n    _this.handleFocusMoveDown = function (e) {\n      return _this.handleFocusMove(e, \"down\");\n    };\n\n    _this.handleFocusMoveDownInternal = function (e) {\n      return _this.handleFocusMoveInternal(e, \"down\");\n    };\n\n    _this.styleBodyRegion = function (region, quadrantType) {\n      var numFrozenColumns = _this.props.numFrozenColumns;\n      var cardinality = Regions.getRegionCardinality(region);\n\n      var style = _this.grid.getRegionStyle(region); // ensure we're not showing borders at the boundary of the frozen-columns area\n\n\n      var canHideRightBorder = (quadrantType === QuadrantType.TOP_LEFT || quadrantType === QuadrantType.LEFT) && numFrozenColumns != null && numFrozenColumns > 0;\n\n      var fixedHeight = _this.grid.getHeight();\n\n      var fixedWidth = _this.grid.getWidth(); // include a correction in some cases to hide borders along quadrant boundaries\n\n\n      var alignmentCorrection = 1;\n      var alignmentCorrectionString = \"-\" + alignmentCorrection + \"px\";\n\n      switch (cardinality) {\n        case RegionCardinality.CELLS:\n          return style;\n\n        case RegionCardinality.FULL_COLUMNS:\n          style.top = alignmentCorrectionString;\n          style.height = fixedHeight + alignmentCorrection;\n          return style;\n\n        case RegionCardinality.FULL_ROWS:\n          style.left = alignmentCorrectionString;\n          style.width = fixedWidth + alignmentCorrection;\n\n          if (canHideRightBorder) {\n            style.right = alignmentCorrectionString;\n          }\n\n          return style;\n\n        case RegionCardinality.FULL_TABLE:\n          style.left = alignmentCorrectionString;\n          style.top = alignmentCorrectionString;\n          style.width = fixedWidth + alignmentCorrection;\n          style.height = fixedHeight + alignmentCorrection;\n\n          if (canHideRightBorder) {\n            style.right = alignmentCorrectionString;\n          }\n\n          return style;\n\n        default:\n          return {\n            display: \"none\"\n          };\n      }\n    };\n\n    _this.styleMenuRegion = function (region) {\n      var viewportRect = _this.state.viewportRect;\n\n      if (viewportRect == null) {\n        return {};\n      }\n\n      var cardinality = Regions.getRegionCardinality(region);\n\n      var style = _this.grid.getRegionStyle(region);\n\n      switch (cardinality) {\n        case RegionCardinality.FULL_TABLE:\n          style.right = \"0px\";\n          style.bottom = \"0px\";\n          style.top = \"0px\";\n          style.left = \"0px\";\n          style.borderBottom = \"none\";\n          style.borderRight = \"none\";\n          return style;\n\n        default:\n          return {\n            display: \"none\"\n          };\n      }\n    };\n\n    _this.styleColumnHeaderRegion = function (region) {\n      var viewportRect = _this.state.viewportRect;\n\n      if (viewportRect == null) {\n        return {};\n      }\n\n      var cardinality = Regions.getRegionCardinality(region);\n\n      var style = _this.grid.getRegionStyle(region);\n\n      switch (cardinality) {\n        case RegionCardinality.FULL_TABLE:\n          style.left = \"-1px\";\n          style.borderLeft = \"none\";\n          style.bottom = \"-1px\";\n          return style;\n\n        case RegionCardinality.FULL_COLUMNS:\n          style.bottom = \"-1px\";\n          return style;\n\n        default:\n          return {\n            display: \"none\"\n          };\n      }\n    };\n\n    _this.styleRowHeaderRegion = function (region) {\n      var viewportRect = _this.state.viewportRect;\n\n      if (viewportRect == null) {\n        return {};\n      }\n\n      var cardinality = Regions.getRegionCardinality(region);\n\n      var style = _this.grid.getRegionStyle(region);\n\n      switch (cardinality) {\n        case RegionCardinality.FULL_TABLE:\n          style.top = \"-1px\";\n          style.borderTop = \"none\";\n          style.right = \"-1px\";\n          return style;\n\n        case RegionCardinality.FULL_ROWS:\n          style.right = \"-1px\";\n          return style;\n\n        default:\n          return {\n            display: \"none\"\n          };\n      }\n    };\n\n    _this.handleColumnWidthChanged = function (columnIndex, width) {\n      var selectedRegions = _this.state.selectedRegions;\n\n      var columnWidths = _this.state.columnWidths.slice();\n\n      if (Regions.hasFullTable(selectedRegions)) {\n        for (var col = 0; col < columnWidths.length; col++) {\n          columnWidths[col] = width;\n        }\n      }\n\n      if (Regions.hasFullColumn(selectedRegions, columnIndex)) {\n        Regions.eachUniqueFullColumn(selectedRegions, function (col) {\n          columnWidths[col] = width;\n        });\n      } else {\n        columnWidths[columnIndex] = width;\n      }\n\n      _this.invalidateGrid();\n\n      _this.setState({\n        columnWidths: columnWidths\n      });\n\n      var onColumnWidthChanged = _this.props.onColumnWidthChanged;\n\n      if (onColumnWidthChanged != null) {\n        onColumnWidthChanged(columnIndex, width);\n      }\n    };\n\n    _this.handleRowHeightChanged = function (rowIndex, height) {\n      var selectedRegions = _this.state.selectedRegions;\n\n      var rowHeights = _this.state.rowHeights.slice();\n\n      if (Regions.hasFullTable(selectedRegions)) {\n        for (var row = 0; row < rowHeights.length; row++) {\n          rowHeights[row] = height;\n        }\n      }\n\n      if (Regions.hasFullRow(selectedRegions, rowIndex)) {\n        Regions.eachUniqueFullRow(selectedRegions, function (row) {\n          rowHeights[row] = height;\n        });\n      } else {\n        rowHeights[rowIndex] = height;\n      }\n\n      _this.invalidateGrid();\n\n      _this.setState({\n        rowHeights: rowHeights\n      });\n\n      var onRowHeightChanged = _this.props.onRowHeightChanged;\n\n      if (onRowHeightChanged != null) {\n        onRowHeightChanged(rowIndex, height);\n      }\n    };\n\n    _this.handleRootScroll = function (_event) {\n      // Bug #211 - Native browser text selection events can cause the root\n      // element to scroll even though it has a overflow:hidden style. The\n      // only viable solution to this is to unscroll the element after the\n      // browser scrolls it.\n      if (_this.rootTableElement != null) {\n        _this.rootTableElement.scrollLeft = 0;\n        _this.rootTableElement.scrollTop = 0;\n      }\n    };\n\n    _this.handleBodyScroll = function (event) {\n      // Prevent the event from propagating to avoid a resize event on the\n      // resize sensor.\n      event.stopPropagation();\n\n      if (_this.locator != null && !_this.state.isLayoutLocked) {\n        var viewportRect = _this.locator.getViewportRect();\n\n        _this.updateViewportRect(viewportRect);\n      }\n    };\n\n    _this.clearSelection = function (_selectedRegions) {\n      _this.handleSelection([]);\n    }; // no good way to call arrow-key keyboard events from tests\n\n    /* istanbul ignore next */\n\n\n    _this.handleFocusMove = function (e, direction) {\n      e.preventDefault();\n      e.stopPropagation();\n      var focusedCell = _this.state.focusedCell;\n\n      if (focusedCell == null) {\n        // halt early if we have a selectedRegionTransform or something else in play that nixes\n        // the focused cell.\n        return;\n      }\n\n      var newFocusedCell = {\n        col: focusedCell.col,\n        row: focusedCell.row,\n        focusSelectionIndex: 0\n      };\n\n      switch (direction) {\n        case \"up\":\n          newFocusedCell.row -= 1;\n          break;\n\n        case \"down\":\n          newFocusedCell.row += 1;\n          break;\n\n        case \"left\":\n          newFocusedCell.col -= 1;\n          break;\n\n        case \"right\":\n          newFocusedCell.col += 1;\n          break;\n\n        default:\n          break;\n      }\n\n      if (newFocusedCell.row < 0 || newFocusedCell.row >= _this.grid.numRows || newFocusedCell.col < 0 || newFocusedCell.col >= _this.grid.numCols) {\n        return;\n      } // change selection to match new focus cell location\n\n\n      var newSelectionRegions = [Regions.cell(newFocusedCell.row, newFocusedCell.col)];\n      var selectedRegionTransform = _this.props.selectedRegionTransform;\n      var transformedSelectionRegions = selectedRegionTransform != null ? newSelectionRegions.map(function (region) {\n        return selectedRegionTransform(region, e);\n      }) : newSelectionRegions;\n\n      _this.handleSelection(transformedSelectionRegions);\n\n      _this.handleFocus(newFocusedCell); // keep the focused cell in view\n\n\n      _this.scrollBodyToFocusedCell(newFocusedCell);\n    }; // no good way to call arrow-key keyboard events from tests\n\n    /* istanbul ignore next */\n\n\n    _this.handleFocusMoveInternal = function (e, direction) {\n      e.preventDefault();\n      e.stopPropagation();\n      var _a = _this.state,\n          focusedCell = _a.focusedCell,\n          selectedRegions = _a.selectedRegions;\n\n      if (focusedCell == null) {\n        // halt early if we have a selectedRegionTransform or something else in play that nixes\n        // the focused cell.\n        return;\n      }\n\n      var newFocusedCell = {\n        col: focusedCell.col,\n        focusSelectionIndex: focusedCell.focusSelectionIndex,\n        row: focusedCell.row\n      }; // if we're not in any particular focus cell region, and one exists, go to the first cell of the first one\n\n      if (focusedCell.focusSelectionIndex == null && selectedRegions.length > 0) {\n        var focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[0], _this.grid.numRows, _this.grid.numCols);\n        newFocusedCell = {\n          col: focusCellRegion.cols[0],\n          focusSelectionIndex: 0,\n          row: focusCellRegion.rows[0]\n        };\n      } else {\n        if (selectedRegions.length === 0) {\n          _this.handleFocusMove(e, direction);\n\n          return;\n        }\n\n        var focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[focusedCell.focusSelectionIndex], _this.grid.numRows, _this.grid.numCols);\n\n        if (focusCellRegion.cols[0] === focusCellRegion.cols[1] && focusCellRegion.rows[0] === focusCellRegion.rows[1] && selectedRegions.length === 1) {\n          _this.handleFocusMove(e, direction);\n\n          return;\n        }\n\n        switch (direction) {\n          case \"up\":\n            newFocusedCell = _this.moveFocusCell(\"row\", \"col\", true, newFocusedCell, focusCellRegion);\n            break;\n\n          case \"left\":\n            newFocusedCell = _this.moveFocusCell(\"col\", \"row\", true, newFocusedCell, focusCellRegion);\n            break;\n\n          case \"down\":\n            newFocusedCell = _this.moveFocusCell(\"row\", \"col\", false, newFocusedCell, focusCellRegion);\n            break;\n\n          case \"right\":\n            newFocusedCell = _this.moveFocusCell(\"col\", \"row\", false, newFocusedCell, focusCellRegion);\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      if (newFocusedCell.row < 0 || newFocusedCell.row >= _this.grid.numRows || newFocusedCell.col < 0 || newFocusedCell.col >= _this.grid.numCols) {\n        return;\n      }\n\n      _this.handleFocus(newFocusedCell); // keep the focused cell in view\n\n\n      _this.scrollBodyToFocusedCell(newFocusedCell);\n    };\n\n    _this.scrollBodyToFocusedCell = function (focusedCell) {\n      var row = focusedCell.row,\n          col = focusedCell.col;\n      var viewportRect = _this.state.viewportRect; // sort keys in normal CSS position order (per the trusty TRBL/\"trouble\" acronym)\n      // tslint:disable:object-literal-sort-keys\n\n      var viewportBounds = {\n        top: viewportRect.top,\n        right: viewportRect.left + viewportRect.width,\n        bottom: viewportRect.top + viewportRect.height,\n        left: viewportRect.left\n      };\n      var focusedCellBounds = {\n        top: _this.grid.getCumulativeHeightBefore(row),\n        right: _this.grid.getCumulativeWidthAt(col),\n        bottom: _this.grid.getCumulativeHeightAt(row),\n        left: _this.grid.getCumulativeWidthBefore(col)\n      }; // tslint:enable:object-literal-sort-keys\n\n      var focusedCellWidth = focusedCellBounds.right - focusedCellBounds.left;\n      var focusedCellHeight = focusedCellBounds.bottom - focusedCellBounds.top;\n      var isFocusedCellWiderThanViewport = focusedCellWidth > viewportRect.width;\n      var isFocusedCellTallerThanViewport = focusedCellHeight > viewportRect.height;\n      var ss = {}; // keep the top end of an overly tall focused cell in view when moving left and right\n      // (without this OR check, the body seesaws to fit the top end, then the bottom end, etc.)\n\n      if (focusedCellBounds.top < viewportBounds.top || isFocusedCellTallerThanViewport) {\n        // scroll up (minus one pixel to avoid clipping the focused-cell border)\n        ss.nextScrollTop = Math.max(0, focusedCellBounds.top - 1);\n      } else if (focusedCellBounds.bottom > viewportBounds.bottom) {\n        // scroll down\n        var scrollDelta = focusedCellBounds.bottom - viewportBounds.bottom;\n        ss.nextScrollTop = viewportBounds.top + scrollDelta;\n      } // keep the left end of an overly wide focused cell in view when moving up and down\n\n\n      if (focusedCellBounds.left < viewportBounds.left || isFocusedCellWiderThanViewport) {\n        // scroll left (again minus one additional pixel)\n        ss.nextScrollLeft = Math.max(0, focusedCellBounds.left - 1);\n      } else if (focusedCellBounds.right > viewportBounds.right) {\n        // scroll right\n        var scrollDelta = focusedCellBounds.right - viewportBounds.right;\n        ss.nextScrollLeft = viewportBounds.left + scrollDelta;\n      }\n\n      _this.syncViewportPosition(ss);\n    };\n\n    _this.handleFocus = function (focusedCell) {\n      if (!_this.props.enableFocusedCell) {\n        // don't set focus state if focus is not allowed\n        return;\n      } // only set focused cell state if not specified in props\n\n\n      if (_this.props.focusedCell == null) {\n        _this.setState({\n          focusedCell: focusedCell\n        });\n      }\n\n      CoreUtils.safeInvoke(_this.props.onFocusedCell, focusedCell);\n    };\n\n    _this.handleSelection = function (selectedRegions) {\n      // only set selectedRegions state if not specified in props\n      if (_this.props.selectedRegions == null) {\n        _this.setState({\n          selectedRegions: selectedRegions\n        });\n      }\n\n      var onSelection = _this.props.onSelection;\n\n      if (onSelection != null) {\n        onSelection(selectedRegions);\n      }\n    };\n\n    _this.handleColumnsReordering = function (verticalGuides) {\n      _this.setState({\n        isReordering: true,\n        verticalGuides: verticalGuides\n      });\n    };\n\n    _this.handleColumnsReordered = function (oldIndex, newIndex, length) {\n      _this.setState({\n        isReordering: false,\n        verticalGuides: undefined\n      });\n\n      CoreUtils.safeInvoke(_this.props.onColumnsReordered, oldIndex, newIndex, length);\n    };\n\n    _this.handleRowsReordering = function (horizontalGuides) {\n      _this.setState({\n        isReordering: true,\n        horizontalGuides: horizontalGuides\n      });\n    };\n\n    _this.handleRowsReordered = function (oldIndex, newIndex, length) {\n      _this.setState({\n        isReordering: false,\n        horizontalGuides: undefined\n      });\n\n      CoreUtils.safeInvoke(_this.props.onRowsReordered, oldIndex, newIndex, length);\n    };\n\n    _this.handleLayoutLock = function (isLayoutLocked) {\n      if (isLayoutLocked === void 0) {\n        isLayoutLocked = false;\n      }\n\n      _this.setState({\n        isLayoutLocked: isLayoutLocked\n      });\n    };\n\n    _this.hasLoadingOption = function (loadingOptions, loadingOption) {\n      if (loadingOptions == null) {\n        return undefined;\n      }\n\n      return loadingOptions.indexOf(loadingOption) >= 0;\n    };\n\n    _this.updateViewportRect = function (nextViewportRect) {\n      var viewportRect = _this.state.viewportRect;\n\n      _this.setState({\n        viewportRect: nextViewportRect\n      });\n\n      var didViewportChange = viewportRect != null && !viewportRect.equals(nextViewportRect) || viewportRect == null && nextViewportRect != null;\n\n      if (didViewportChange) {\n        _this.invokeOnVisibleCellsChangeCallback(nextViewportRect);\n      }\n    };\n\n    _this.getMaxFrozenColumnIndex = function () {\n      var numFrozenColumns = _this.state.numFrozenColumnsClamped;\n      return numFrozenColumns != null ? numFrozenColumns - 1 : undefined;\n    };\n\n    _this.getMaxFrozenRowIndex = function () {\n      var numFrozenRows = _this.state.numFrozenRowsClamped;\n      return numFrozenRows != null ? numFrozenRows - 1 : undefined;\n    };\n\n    _this.handleColumnResizeGuide = function (verticalGuides) {\n      _this.setState({\n        verticalGuides: verticalGuides\n      });\n    };\n\n    _this.handleRowResizeGuide = function (horizontalGuides) {\n      _this.setState({\n        horizontalGuides: horizontalGuides\n      });\n    };\n\n    var _a = _this.props,\n        children = _a.children,\n        columnWidths = _a.columnWidths,\n        defaultRowHeight = _a.defaultRowHeight,\n        defaultColumnWidth = _a.defaultColumnWidth,\n        numRows = _a.numRows,\n        rowHeights = _a.rowHeights;\n    var childrenArray = React.Children.toArray(children);\n    var columnIdToIndex = Table_1.createColumnIdIndex(childrenArray); // Create height/width arrays using the lengths from props and\n    // children, the default values from props, and finally any sparse\n    // arrays passed into props.\n\n    var newColumnWidths = childrenArray.map(function () {\n      return defaultColumnWidth;\n    });\n    newColumnWidths = Utils.assignSparseValues(newColumnWidths, columnWidths);\n    var newRowHeights = Utils.times(numRows, function () {\n      return defaultRowHeight;\n    });\n    newRowHeights = Utils.assignSparseValues(newRowHeights, rowHeights);\n    var selectedRegions = props.selectedRegions == null ? [] : props.selectedRegions;\n    var focusedCell = FocusedCellUtils.getInitialFocusedCell(props.enableFocusedCell, props.focusedCell, undefined, selectedRegions);\n    _this.state = {\n      childrenArray: childrenArray,\n      columnIdToIndex: columnIdToIndex,\n      columnWidths: newColumnWidths,\n      focusedCell: focusedCell,\n      isLayoutLocked: false,\n      isReordering: false,\n      numFrozenColumnsClamped: clampNumFrozenColumns(props),\n      numFrozenRowsClamped: clampNumFrozenRows(props),\n      rowHeights: newRowHeights,\n      selectedRegions: selectedRegions\n    };\n    return _this;\n  }\n\n  Table_1 = Table;\n\n  Table.getDerivedStateFromProps = function (props, state) {\n    var children = props.children,\n        defaultColumnWidth = props.defaultColumnWidth,\n        defaultRowHeight = props.defaultRowHeight,\n        enableFocusedCell = props.enableFocusedCell,\n        focusedCell = props.focusedCell,\n        numRows = props.numRows,\n        selectedRegions = props.selectedRegions,\n        selectionModes = props.selectionModes; // assign values from state if uncontrolled\n\n    var columnWidths = props.columnWidths,\n        rowHeights = props.rowHeights;\n\n    if (columnWidths == null) {\n      columnWidths = state.columnWidths;\n    }\n\n    if (rowHeights == null) {\n      rowHeights = state.rowHeights;\n    }\n\n    var newChildrenArray = React.Children.toArray(children);\n    var didChildrenChange = newChildrenArray !== state.childrenArray;\n    var numCols = newChildrenArray.length;\n    var newColumnWidths = columnWidths;\n\n    if (columnWidths !== state.columnWidths || didChildrenChange) {\n      // Try to maintain widths of columns by looking up the width of the\n      // column that had the same `ID` prop. If none is found, use the\n      // previous width at the same index.\n      var previousColumnWidths = newChildrenArray.map(function (child, index) {\n        var mappedIndex = state.columnIdToIndex[child.props.id];\n        return state.columnWidths[mappedIndex != null ? mappedIndex : index];\n      }); // Make sure the width/height arrays have the correct length, but keep\n      // as many existing widths/heights as possible. Also, apply the\n      // sparse width/heights from props.\n\n      newColumnWidths = Utils.arrayOfLength(newColumnWidths, numCols, defaultColumnWidth);\n      newColumnWidths = Utils.assignSparseValues(newColumnWidths, previousColumnWidths);\n      newColumnWidths = Utils.assignSparseValues(newColumnWidths, columnWidths);\n    }\n\n    var newRowHeights = rowHeights;\n\n    if (rowHeights !== state.rowHeights || numRows !== state.rowHeights.length) {\n      newRowHeights = Utils.arrayOfLength(newRowHeights, numRows, defaultRowHeight);\n      newRowHeights = Utils.assignSparseValues(newRowHeights, rowHeights);\n    }\n\n    var newSelectedRegions = selectedRegions;\n\n    if (selectedRegions == null) {\n      // if we're in uncontrolled mode, filter out all selected regions that don't\n      // fit in the current new table dimensions\n      newSelectedRegions = state.selectedRegions.filter(function (region) {\n        var regionCardinality = Regions.getRegionCardinality(region);\n        return Table_1.isSelectionModeEnabled(props, regionCardinality, selectionModes) && Regions.isRegionValidForTable(region, numRows, numCols);\n      });\n    }\n\n    var newFocusedCell = FocusedCellUtils.getInitialFocusedCell(enableFocusedCell, focusedCell, state.focusedCell, newSelectedRegions);\n    var nextState = {\n      childrenArray: newChildrenArray,\n      columnIdToIndex: didChildrenChange ? Table_1.createColumnIdIndex(newChildrenArray) : state.columnIdToIndex,\n      columnWidths: newColumnWidths,\n      focusedCell: newFocusedCell,\n      numFrozenColumnsClamped: clampNumFrozenColumns(props),\n      numFrozenRowsClamped: clampNumFrozenRows(props),\n      rowHeights: newRowHeights,\n      selectedRegions: newSelectedRegions\n    };\n\n    if (!CoreUtils.deepCompareKeys(state, nextState, Table_1.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST)) {\n      return nextState;\n    }\n\n    return null;\n  };\n\n  Table.createColumnIdIndex = function (children) {\n    var columnIdToIndex = {};\n\n    for (var i = 0; i < children.length; i++) {\n      var key = children[i].props.id;\n\n      if (key != null) {\n        columnIdToIndex[String(key)] = i;\n      }\n    }\n\n    return columnIdToIndex;\n  };\n\n  Table.isSelectionModeEnabled = function (props, selectionMode, selectionModes) {\n    if (selectionModes === void 0) {\n      selectionModes = props.selectionModes;\n    }\n\n    var children = props.children,\n        numRows = props.numRows;\n    var numColumns = React.Children.count(children);\n    return selectionModes.indexOf(selectionMode) >= 0 && numRows > 0 && numColumns > 0;\n  }; // Instance methods\n  // ================\n\n  /**\n   * __Experimental!__ Resizes all rows in the table to the approximate\n   * maximum height of wrapped cell content in each row. Works best when each\n   * cell contains plain text of a consistent font style (though font style\n   * may vary between cells). Since this function uses approximate\n   * measurements, results may not be perfect.\n   *\n   * Approximation parameters can be configured for the entire table or on a\n   * per-cell basis. Default values are fine-tuned to work well with default\n   * Table font styles.\n   */\n\n\n  Table.prototype.resizeRowsByApproximateHeight = function (getCellText, options) {\n    var numRows = this.props.numRows;\n    var columnWidths = this.state.columnWidths;\n    var numColumns = columnWidths.length;\n    var rowHeights = [];\n\n    for (var rowIndex = 0; rowIndex < numRows; rowIndex++) {\n      var maxCellHeightInRow = 0; // iterate through each cell in the row\n\n      for (var columnIndex = 0; columnIndex < numColumns; columnIndex++) {\n        // resolve all parameters to raw values\n        var _a = this.resolveResizeRowsByApproximateHeightOptions(options, rowIndex, columnIndex),\n            approxCharWidth = _a.getApproximateCharWidth,\n            approxLineHeight = _a.getApproximateLineHeight,\n            horizontalPadding = _a.getCellHorizontalPadding,\n            numBufferLines = _a.getNumBufferLines;\n\n        var cellText = getCellText(rowIndex, columnIndex);\n        var approxCellHeight = Utils.getApproxCellHeight(cellText, columnWidths[columnIndex], approxCharWidth, approxLineHeight, horizontalPadding, numBufferLines);\n\n        if (approxCellHeight > maxCellHeightInRow) {\n          maxCellHeightInRow = approxCellHeight;\n        }\n      }\n\n      rowHeights.push(maxCellHeightInRow);\n    }\n\n    this.invalidateGrid();\n    this.setState({\n      rowHeights: rowHeights\n    });\n  };\n  /**\n   * Resize all rows in the table to the height of the tallest visible cell in the specified columns.\n   * If no indices are provided, default to using the tallest visible cell from all columns in view.\n   */\n\n\n  Table.prototype.resizeRowsByTallestCell = function (columnIndices) {\n    var _this = this;\n\n    var tallest = 0;\n\n    if (columnIndices == null) {\n      // Consider all columns currently in viewport\n      var viewportColumnIndices = this.grid.getColumnIndicesInRect(this.state.viewportRect);\n\n      for (var col = viewportColumnIndices.columnIndexStart; col <= viewportColumnIndices.columnIndexEnd; col++) {\n        tallest = Math.max(tallest, this.locator.getTallestVisibleCellInColumn(col));\n      }\n    } else {\n      var columnIndicesArray = Array.isArray(columnIndices) ? columnIndices : [columnIndices];\n      var tallestByColumns = columnIndicesArray.map(function (col) {\n        return _this.locator.getTallestVisibleCellInColumn(col);\n      });\n      tallest = Math.max.apply(Math, tallestByColumns);\n    }\n\n    var rowHeights = Array(this.state.rowHeights.length).fill(tallest);\n    this.invalidateGrid();\n    this.setState({\n      rowHeights: rowHeights\n    });\n  };\n  /**\n   * Scrolls the table to the target region in a fashion appropriate to the target region's\n   * cardinality:\n   *\n   * - CELLS: Scroll the top-left cell in the target region to the top-left corner of the viewport.\n   * - FULL_ROWS: Scroll the top-most row in the target region to the top of the viewport.\n   * - FULL_COLUMNS: Scroll the left-most column in the target region to the left side of the viewport.\n   * - FULL_TABLE: Scroll the top-left cell in the table to the top-left corner of the viewport.\n   *\n   * If there are active frozen rows and/or columns, the target region will be positioned in the\n   * top-left corner of the non-frozen area (unless the target region itself is in the frozen\n   * area).\n   *\n   * If the target region is close to the bottom-right corner of the table, this function will\n   * simply scroll the target region as close to the top-left as possible until the bottom-right\n   * corner is reached.\n   */\n\n\n  Table.prototype.scrollToRegion = function (region) {\n    var _a = this.state,\n        numFrozenColumns = _a.numFrozenColumnsClamped,\n        numFrozenRows = _a.numFrozenRowsClamped;\n    var _b = this.state.viewportRect,\n        currScrollLeft = _b.left,\n        currScrollTop = _b.top;\n\n    var _c = ScrollUtils.getScrollPositionForRegion(region, currScrollLeft, currScrollTop, this.grid.getCumulativeWidthBefore, this.grid.getCumulativeHeightBefore, numFrozenRows, numFrozenColumns),\n        scrollLeft = _c.scrollLeft,\n        scrollTop = _c.scrollTop;\n\n    var correctedScrollLeft = this.shouldDisableHorizontalScroll() ? 0 : scrollLeft;\n    var correctedScrollTop = this.shouldDisableVerticalScroll() ? 0 : scrollTop; // defer to the quadrant stack to keep all quadrant positions in sync\n\n    this.quadrantStackInstance.scrollToPosition(correctedScrollLeft, correctedScrollTop);\n  }; // React lifecycle\n  // ===============\n\n\n  Table.prototype.getChildContext = function () {\n    return {\n      enableColumnInteractionBar: this.props.enableColumnInteractionBar\n    };\n  };\n\n  Table.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    var propKeysBlacklist = {\n      exclude: Table_1.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST\n    };\n    var stateKeysBlacklist = {\n      exclude: Table_1.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST\n    };\n    return !CoreUtils.shallowCompareKeys(this.props, nextProps, propKeysBlacklist) || !CoreUtils.shallowCompareKeys(this.state, nextState, stateKeysBlacklist) || !CoreUtils.deepCompareKeys(this.props, nextProps, Table_1.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST) || !CoreUtils.deepCompareKeys(this.state, nextState, Table_1.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST);\n  };\n\n  Table.prototype.render = function () {\n    var _a;\n\n    var _b = this.props,\n        children = _b.children,\n        className = _b.className,\n        enableRowHeader = _b.enableRowHeader,\n        loadingOptions = _b.loadingOptions,\n        numRows = _b.numRows,\n        enableColumnInteractionBar = _b.enableColumnInteractionBar;\n    var _c = this.state,\n        horizontalGuides = _c.horizontalGuides,\n        numFrozenColumnsClamped = _c.numFrozenColumnsClamped,\n        numFrozenRowsClamped = _c.numFrozenRowsClamped,\n        verticalGuides = _c.verticalGuides;\n    this.validateGrid();\n    var classes = classNames(Classes.TABLE_CONTAINER, (_a = {}, _a[Classes.TABLE_REORDERING] = this.state.isReordering, _a[Classes.TABLE_NO_VERTICAL_SCROLL] = this.shouldDisableVerticalScroll(), _a[Classes.TABLE_NO_HORIZONTAL_SCROLL] = this.shouldDisableHorizontalScroll(), _a[Classes.TABLE_SELECTION_ENABLED] = Table_1.isSelectionModeEnabled(this.props, RegionCardinality.CELLS), _a[Classes.TABLE_NO_ROWS] = numRows === 0, _a), className);\n    return React.createElement(\"div\", {\n      className: classes,\n      ref: this.refHandlers.rootTable,\n      onScroll: this.handleRootScroll\n    }, React.createElement(TableQuadrantStack, {\n      bodyRef: this.refHandlers.cellContainer,\n      bodyRenderer: this.renderBody,\n      columnHeaderCellRenderer: this.renderColumnHeader,\n      columnHeaderRef: this.refHandlers.columnHeader,\n      enableColumnInteractionBar: enableColumnInteractionBar,\n      enableRowHeader: enableRowHeader,\n      grid: this.grid,\n      handleColumnResizeGuide: this.handleColumnResizeGuide,\n      handleColumnsReordering: this.handleColumnsReordering,\n      handleRowResizeGuide: this.handleRowResizeGuide,\n      handleRowsReordering: this.handleRowsReordering,\n      isHorizontalScrollDisabled: this.shouldDisableHorizontalScroll(),\n      isVerticalScrollDisabled: this.shouldDisableVerticalScroll(),\n      loadingOptions: loadingOptions,\n      numColumns: React.Children.count(children),\n      numFrozenColumns: numFrozenColumnsClamped,\n      numFrozenRows: numFrozenRowsClamped,\n      numRows: numRows,\n      onScroll: this.handleBodyScroll,\n      ref: this.refHandlers.quadrantStack,\n      menuRenderer: this.renderMenu,\n      rowHeaderCellRenderer: this.renderRowHeader,\n      rowHeaderRef: this.refHandlers.rowHeader,\n      scrollContainerRef: this.refHandlers.scrollContainer\n    }), React.createElement(\"div\", {\n      className: classNames(Classes.TABLE_OVERLAY_LAYER, Classes.TABLE_OVERLAY_REORDERING_CURSOR)\n    }), React.createElement(GuideLayer, {\n      className: Classes.TABLE_RESIZE_GUIDES,\n      verticalGuides: verticalGuides,\n      horizontalGuides: horizontalGuides\n    }));\n  };\n\n  Table.prototype.renderHotkeys = function () {\n    var hotkeys = [this.maybeRenderCopyHotkey(), this.maybeRenderSelectAllHotkey(), this.maybeRenderFocusHotkeys(), this.maybeRenderSelectionResizeHotkeys()];\n    return React.createElement(Hotkeys, null, hotkeys.filter(function (element) {\n      return element !== undefined;\n    }));\n  };\n  /**\n   * When the component mounts, the HTML Element refs will be available, so\n   * we constructor the Locator, which queries the elements' bounding\n   * ClientRects.\n   */\n\n\n  Table.prototype.componentDidMount = function () {\n    var _this = this;\n\n    this.validateGrid();\n    this.locator = new Locator(this.rootTableElement, this.scrollContainerElement, this.cellContainerElement);\n    this.updateLocator();\n    this.updateViewportRect(this.locator.getViewportRect());\n    this.resizeSensorDetach = ResizeSensor.attach(this.rootTableElement, function () {\n      if (!_this.state.isLayoutLocked) {\n        _this.updateViewportRect(_this.locator.getViewportRect());\n      }\n    });\n  };\n\n  Table.prototype.componentWillUnmount = function () {\n    if (this.resizeSensorDetach != null) {\n      this.resizeSensorDetach();\n      delete this.resizeSensorDetach;\n    }\n\n    this.didCompletelyMount = false;\n  };\n\n  Table.prototype.getSnapshotBeforeUpdate = function () {\n    var viewportRect = this.state.viewportRect;\n    this.validateGrid();\n    var tableBottom = this.grid.getCumulativeHeightAt(this.grid.numRows - 1);\n    var tableRight = this.grid.getCumulativeWidthAt(this.grid.numCols - 1);\n    var nextScrollTop = tableBottom < viewportRect.top + viewportRect.height ? // scroll the last row into view\n    Math.max(0, tableBottom - viewportRect.height) : undefined;\n    var nextScrollLeft = tableRight < viewportRect.left + viewportRect.width ? // scroll the last column into view\n    Math.max(0, tableRight - viewportRect.width) : undefined; // these will only be defined if they differ from viewportRect\n\n    return {\n      nextScrollLeft: nextScrollLeft,\n      nextScrollTop: nextScrollTop\n    };\n  };\n\n  Table.prototype.componentDidUpdate = function (prevProps, prevState, snapshot) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState, snapshot);\n\n    var didChildrenChange = React.Children.toArray(this.props.children) !== this.state.childrenArray;\n    var shouldInvalidateGrid = didChildrenChange || this.props.columnWidths !== prevState.columnWidths || this.props.rowHeights !== prevState.rowHeights || this.props.numRows !== prevProps.numRows || this.props.forceRerenderOnSelectionChange && this.props.selectedRegions !== prevProps.selectedRegions;\n\n    if (shouldInvalidateGrid) {\n      this.invalidateGrid();\n    }\n\n    if (this.locator != null) {\n      this.validateGrid();\n      this.updateLocator();\n    } // When true, we'll need to imperatively synchronize quadrant views after\n    // the update. This check lets us avoid expensively diff'ing columnWidths\n    // and rowHeights in <TableQuadrantStack> on each update.\n\n\n    var didUpdateColumnOrRowSizes = !CoreUtils.arraysEqual(this.state.columnWidths, prevState.columnWidths) || !CoreUtils.arraysEqual(this.state.rowHeights, prevState.rowHeights);\n\n    if (didUpdateColumnOrRowSizes) {\n      this.quadrantStackInstance.synchronizeQuadrantViews();\n      this.syncViewportPosition(snapshot);\n    }\n  };\n\n  Table.prototype.validateProps = function (props) {\n    var children = props.children,\n        columnWidths = props.columnWidths,\n        numFrozenColumns = props.numFrozenColumns,\n        numFrozenRows = props.numFrozenRows,\n        numRows = props.numRows,\n        rowHeights = props.rowHeights;\n    var numColumns = React.Children.count(children); // do cheap error-checking first.\n\n    if (numRows != null && numRows < 0) {\n      throw new Error(Errors.TABLE_NUM_ROWS_NEGATIVE);\n    }\n\n    if (numFrozenRows != null && numFrozenRows < 0) {\n      throw new Error(Errors.TABLE_NUM_FROZEN_ROWS_NEGATIVE);\n    }\n\n    if (numFrozenColumns != null && numFrozenColumns < 0) {\n      throw new Error(Errors.TABLE_NUM_FROZEN_COLUMNS_NEGATIVE);\n    }\n\n    if (numRows != null && rowHeights != null && rowHeights.length !== numRows) {\n      throw new Error(Errors.TABLE_NUM_ROWS_ROW_HEIGHTS_MISMATCH);\n    }\n\n    if (numColumns != null && columnWidths != null && columnWidths.length !== numColumns) {\n      throw new Error(Errors.TABLE_NUM_COLUMNS_COLUMN_WIDTHS_MISMATCH);\n    }\n\n    React.Children.forEach(children, function (child) {\n      if (!CoreUtils.isElementOfType(child, Column)) {\n        throw new Error(Errors.TABLE_NON_COLUMN_CHILDREN_WARNING);\n      }\n    }); // these are recoverable scenarios, so just print a warning.\n\n    if (numFrozenRows != null && numRows != null && numFrozenRows > numRows) {\n      console.warn(Errors.TABLE_NUM_FROZEN_ROWS_BOUND_WARNING);\n    }\n\n    if (numFrozenColumns != null && numFrozenColumns > numColumns) {\n      console.warn(Errors.TABLE_NUM_FROZEN_COLUMNS_BOUND_WARNING);\n    }\n  }; // Hotkeys\n  // =======\n\n\n  Table.prototype.maybeRenderCopyHotkey = function () {\n    var getCellClipboardData = this.props.getCellClipboardData;\n\n    if (getCellClipboardData != null) {\n      return React.createElement(Hotkey, {\n        key: \"copy-hotkey\",\n        label: \"Copy selected table cells\",\n        group: \"Table\",\n        combo: \"mod+c\",\n        onKeyDown: this.handleCopy\n      });\n    } else {\n      return undefined;\n    }\n  };\n\n  Table.prototype.maybeRenderSelectionResizeHotkeys = function () {\n    var _a = this.props,\n        enableMultipleSelection = _a.enableMultipleSelection,\n        selectionModes = _a.selectionModes;\n    var isSomeSelectionModeEnabled = selectionModes.length > 0;\n\n    if (enableMultipleSelection && isSomeSelectionModeEnabled) {\n      return [React.createElement(Hotkey, {\n        key: \"resize-selection-up\",\n        label: \"Resize selection upward\",\n        group: \"Table\",\n        combo: \"shift+up\",\n        onKeyDown: this.handleSelectionResizeUp\n      }), React.createElement(Hotkey, {\n        key: \"resize-selection-down\",\n        label: \"Resize selection downward\",\n        group: \"Table\",\n        combo: \"shift+down\",\n        onKeyDown: this.handleSelectionResizeDown\n      }), React.createElement(Hotkey, {\n        key: \"resize-selection-left\",\n        label: \"Resize selection leftward\",\n        group: \"Table\",\n        combo: \"shift+left\",\n        onKeyDown: this.handleSelectionResizeLeft\n      }), React.createElement(Hotkey, {\n        key: \"resize-selection-right\",\n        label: \"Resize selection rightward\",\n        group: \"Table\",\n        combo: \"shift+right\",\n        onKeyDown: this.handleSelectionResizeRight\n      })];\n    } else {\n      return undefined;\n    }\n  };\n\n  Table.prototype.maybeRenderFocusHotkeys = function () {\n    var enableFocusedCell = this.props.enableFocusedCell;\n\n    if (enableFocusedCell != null) {\n      return [React.createElement(Hotkey, {\n        key: \"move left\",\n        label: \"Move focus cell left\",\n        group: \"Table\",\n        combo: \"left\",\n        onKeyDown: this.handleFocusMoveLeft\n      }), React.createElement(Hotkey, {\n        key: \"move right\",\n        label: \"Move focus cell right\",\n        group: \"Table\",\n        combo: \"right\",\n        onKeyDown: this.handleFocusMoveRight\n      }), React.createElement(Hotkey, {\n        key: \"move up\",\n        label: \"Move focus cell up\",\n        group: \"Table\",\n        combo: \"up\",\n        onKeyDown: this.handleFocusMoveUp\n      }), React.createElement(Hotkey, {\n        key: \"move down\",\n        label: \"Move focus cell down\",\n        group: \"Table\",\n        combo: \"down\",\n        onKeyDown: this.handleFocusMoveDown\n      }), React.createElement(Hotkey, {\n        key: \"move tab\",\n        label: \"Move focus cell tab\",\n        group: \"Table\",\n        combo: \"tab\",\n        onKeyDown: this.handleFocusMoveRightInternal,\n        allowInInput: true\n      }), React.createElement(Hotkey, {\n        key: \"move shift-tab\",\n        label: \"Move focus cell shift tab\",\n        group: \"Table\",\n        combo: \"shift+tab\",\n        onKeyDown: this.handleFocusMoveLeftInternal,\n        allowInInput: true\n      }), React.createElement(Hotkey, {\n        key: \"move enter\",\n        label: \"Move focus cell enter\",\n        group: \"Table\",\n        combo: \"enter\",\n        onKeyDown: this.handleFocusMoveDownInternal,\n        allowInInput: true\n      }), React.createElement(Hotkey, {\n        key: \"move shift-enter\",\n        label: \"Move focus cell shift enter\",\n        group: \"Table\",\n        combo: \"shift+enter\",\n        onKeyDown: this.handleFocusMoveUpInternal,\n        allowInInput: true\n      })];\n    } else {\n      return [];\n    }\n  };\n\n  Table.prototype.maybeRenderSelectAllHotkey = function () {\n    if (Table_1.isSelectionModeEnabled(this.props, RegionCardinality.FULL_TABLE)) {\n      return React.createElement(Hotkey, {\n        key: \"select-all-hotkey\",\n        label: \"Select all\",\n        group: \"Table\",\n        combo: \"mod+a\",\n        onKeyDown: this.handleSelectAllHotkey\n      });\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Replaces the selected region at the specified array index, with the\n   * region provided.\n   */\n\n\n  Table.prototype.updateSelectedRegionAtIndex = function (region, index) {\n    var _a = this.props,\n        children = _a.children,\n        numRows = _a.numRows;\n    var selectedRegions = this.state.selectedRegions;\n    var numColumns = React.Children.count(children);\n    var maxRowIndex = Math.max(0, numRows - 1);\n    var maxColumnIndex = Math.max(0, numColumns - 1);\n    var clampedNextRegion = Regions.clampRegion(region, maxRowIndex, maxColumnIndex);\n    var nextSelectedRegions = Regions.update(selectedRegions, clampedNextRegion, index);\n    this.handleSelection(nextSelectedRegions);\n  }; // Quadrant refs\n  // =============\n\n\n  Table.prototype.moveFocusCell = function (primaryAxis, secondaryAxis, isUpOrLeft, newFocusedCell, focusCellRegion) {\n    var selectedRegions = this.state.selectedRegions;\n    var primaryAxisPlural = primaryAxis === \"row\" ? \"rows\" : \"cols\";\n    var secondaryAxisPlural = secondaryAxis === \"row\" ? \"rows\" : \"cols\";\n    var movementDirection = isUpOrLeft ? -1 : +1;\n    var regionIntervalIndex = isUpOrLeft ? 1 : 0; // try moving the cell in the direction along the primary axis\n\n    newFocusedCell[primaryAxis] += movementDirection;\n    var isPrimaryIndexOutOfBounds = isUpOrLeft ? newFocusedCell[primaryAxis] < focusCellRegion[primaryAxisPlural][0] : newFocusedCell[primaryAxis] > focusCellRegion[primaryAxisPlural][1];\n\n    if (isPrimaryIndexOutOfBounds) {\n      // if we moved outside the bounds of selection region,\n      // move to the start (or end) of the primary axis, and move one along the secondary\n      newFocusedCell[primaryAxis] = focusCellRegion[primaryAxisPlural][regionIntervalIndex];\n      newFocusedCell[secondaryAxis] += movementDirection;\n      var isSecondaryIndexOutOfBounds = isUpOrLeft ? newFocusedCell[secondaryAxis] < focusCellRegion[secondaryAxisPlural][0] : newFocusedCell[secondaryAxis] > focusCellRegion[secondaryAxisPlural][1];\n\n      if (isSecondaryIndexOutOfBounds) {\n        // if moving along the secondary also moves us outside\n        // go to the start (or end) of the next (or previous region)\n        // (note that if there's only one region you'll be moving to the opposite corner, which is fine)\n        var newFocusCellSelectionIndex = newFocusedCell.focusSelectionIndex + movementDirection; // newFocusCellSelectionIndex should be one more (or less), unless we need to wrap around\n\n        if (isUpOrLeft ? newFocusCellSelectionIndex < 0 : newFocusCellSelectionIndex >= selectedRegions.length) {\n          newFocusCellSelectionIndex = isUpOrLeft ? selectedRegions.length - 1 : 0;\n        }\n\n        var newFocusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[newFocusCellSelectionIndex], this.grid.numRows, this.grid.numCols);\n        newFocusedCell = {\n          col: newFocusCellRegion.cols[regionIntervalIndex],\n          focusSelectionIndex: newFocusCellSelectionIndex,\n          row: newFocusCellRegion.rows[regionIntervalIndex]\n        };\n      }\n    }\n\n    return newFocusedCell;\n  };\n\n  Table.prototype.shouldDisableVerticalScroll = function () {\n    var enableGhostCells = this.props.enableGhostCells;\n    var viewportRect = this.state.viewportRect;\n    var rowIndices = this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);\n    var isViewportUnscrolledVertically = viewportRect != null && viewportRect.top === 0;\n    var areRowHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, TableLoadingOption.ROW_HEADERS);\n    var areGhostRowsVisible = enableGhostCells && this.grid.isGhostIndex(rowIndices.rowIndexEnd, 0);\n    return areGhostRowsVisible && (isViewportUnscrolledVertically || areRowHeadersLoading);\n  };\n\n  Table.prototype.shouldDisableHorizontalScroll = function () {\n    var enableGhostCells = this.props.enableGhostCells;\n    var viewportRect = this.state.viewportRect;\n    var columnIndices = this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells);\n    var isViewportUnscrolledHorizontally = viewportRect != null && viewportRect.left === 0;\n    var areGhostColumnsVisible = enableGhostCells && this.grid.isGhostColumn(columnIndices.columnIndexEnd);\n    var areColumnHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, TableLoadingOption.COLUMN_HEADERS);\n    return areGhostColumnsVisible && (isViewportUnscrolledHorizontally || areColumnHeadersLoading);\n  };\n\n  Table.prototype.getColumnProps = function (columnIndex) {\n    var column = this.state.childrenArray[columnIndex];\n    return column === undefined ? undefined : column.props;\n  };\n\n  Table.prototype.isGuidesShowing = function () {\n    return this.state.verticalGuides != null || this.state.horizontalGuides != null;\n  };\n\n  Table.prototype.getEnabledSelectionHandler = function (selectionMode) {\n    if (!Table_1.isSelectionModeEnabled(this.props, selectionMode)) {\n      // If the selection mode isn't enabled, return a callback that\n      // will clear the selection. For example, if row selection is\n      // disabled, clicking on the row header will clear the table's\n      // selection. If all selection modes are enabled, clicking on the\n      // same region twice will clear the selection.\n      return this.clearSelection;\n    } else {\n      return this.handleSelection;\n    }\n  };\n\n  Table.prototype.invalidateGrid = function () {\n    this.grid = null;\n  };\n\n  Table.prototype.validateGrid = function () {\n    if (this.grid == null) {\n      var _a = this.props,\n          defaultRowHeight = _a.defaultRowHeight,\n          defaultColumnWidth = _a.defaultColumnWidth;\n      var _b = this.state,\n          rowHeights = _b.rowHeights,\n          columnWidths = _b.columnWidths;\n      this.grid = new Grid(rowHeights, columnWidths, Grid.DEFAULT_BLEED, defaultRowHeight, defaultColumnWidth);\n      this.invokeOnVisibleCellsChangeCallback(this.state.viewportRect);\n    }\n  };\n  /**\n   * Renders a `RegionLayer`, applying styles to the regions using the\n   * supplied `IRegionStyler`. `RegionLayer` is a `PureRender` component, so\n   * the `IRegionStyler` should be a new instance on every render if we\n   * intend to redraw the region layer.\n   */\n\n\n  Table.prototype.maybeRenderRegions = function (getRegionStyle, quadrantType) {\n    if (this.isGuidesShowing() && !this.state.isReordering) {\n      // we want to show guides *and* the selection styles when reordering rows or columns\n      return undefined;\n    }\n\n    var regionGroups = Regions.joinStyledRegionGroups(this.state.selectedRegions, this.props.styledRegionGroups, this.state.focusedCell);\n    return regionGroups.map(function (regionGroup, index) {\n      var regionStyles = regionGroup.regions.map(function (region) {\n        return getRegionStyle(region, quadrantType);\n      });\n      return React.createElement(RegionLayer, {\n        className: classNames(regionGroup.className),\n        key: index,\n        regions: regionGroup.regions,\n        regionStyles: regionStyles\n      });\n    });\n  };\n\n  Table.prototype.syncViewportPosition = function (_a) {\n    var nextScrollLeft = _a.nextScrollLeft,\n        nextScrollTop = _a.nextScrollTop;\n    var viewportRect = this.state.viewportRect;\n\n    if (nextScrollLeft !== undefined || nextScrollTop !== undefined) {\n      // we need to modify the scroll container explicitly for the viewport to shift. in so\n      // doing, we add the size of the header elements, which are not technically part of the\n      // \"grid\" concept (the grid only consists of body cells at present).\n      if (nextScrollTop !== undefined) {\n        var topCorrection = this.shouldDisableVerticalScroll() ? 0 : this.columnHeaderElement.clientHeight;\n        this.scrollContainerElement.scrollTop = nextScrollTop + topCorrection;\n      }\n\n      if (nextScrollLeft !== undefined) {\n        var leftCorrection = this.shouldDisableHorizontalScroll() || this.rowHeaderElement == null ? 0 : this.rowHeaderElement.clientWidth;\n        this.scrollContainerElement.scrollLeft = nextScrollLeft + leftCorrection;\n      }\n\n      var nextViewportRect = new Rect(nextScrollLeft, nextScrollTop, viewportRect.width, viewportRect.height);\n      this.updateViewportRect(nextViewportRect);\n    }\n  };\n\n  Table.prototype.updateLocator = function () {\n    this.locator.setGrid(this.grid).setNumFrozenRows(this.state.numFrozenRowsClamped).setNumFrozenColumns(this.state.numFrozenColumnsClamped);\n  };\n\n  Table.prototype.invokeOnVisibleCellsChangeCallback = function (viewportRect) {\n    var columnIndices = this.grid.getColumnIndicesInRect(viewportRect);\n    var rowIndices = this.grid.getRowIndicesInRect(viewportRect);\n    CoreUtils.safeInvoke(this.props.onVisibleCellsChange, rowIndices, columnIndices);\n  };\n  /**\n   * Normalizes RenderMode.BATCH_ON_UPDATE into RenderMode.{BATCH,NONE}. We do\n   * this because there are actually multiple updates required before the\n   * <Table> is considered fully \"mounted,\" and adding that knowledge to child\n   * components would lead to tight coupling. Thus, keep it simple for them.\n   */\n\n\n  Table.prototype.getNormalizedRenderMode = function () {\n    var renderMode = this.props.renderMode;\n    var shouldBatchRender = renderMode === RenderMode.BATCH || renderMode === RenderMode.BATCH_ON_UPDATE && this.didCompletelyMount;\n    return shouldBatchRender ? RenderMode.BATCH : RenderMode.NONE;\n  };\n  /**\n   * Returns an object with option keys mapped to their resolved values\n   * (falling back to default values as necessary).\n   */\n\n\n  Table.prototype.resolveResizeRowsByApproximateHeightOptions = function (options, rowIndex, columnIndex) {\n    var optionKeys = Object.keys(Table_1.resizeRowsByApproximateHeightDefaults);\n\n    var optionReducer = function optionReducer(agg, key) {\n      agg[key] = options != null && options[key] != null ? CoreUtils.safeInvokeOrValue(options[key], rowIndex, columnIndex) : Table_1.resizeRowsByApproximateHeightDefaults[key];\n      return agg;\n    };\n\n    var resolvedOptions = optionKeys.reduce(optionReducer, {});\n    return resolvedOptions;\n  };\n\n  var Table_1;\n  Table.displayName = DISPLAYNAME_PREFIX + \".Table\";\n  Table.defaultProps = {\n    defaultColumnWidth: 150,\n    defaultRowHeight: 20,\n    enableFocusedCell: false,\n    enableGhostCells: false,\n    enableMultipleSelection: true,\n    enableRowHeader: true,\n    forceRerenderOnSelectionChange: false,\n    loadingOptions: [],\n    minColumnWidth: 50,\n    minRowHeight: 20,\n    numFrozenColumns: 0,\n    numFrozenRows: 0,\n    numRows: 0,\n    renderMode: RenderMode.BATCH_ON_UPDATE,\n    rowHeaderCellRenderer: renderDefaultRowHeader,\n    selectionModes: SelectionModes.ALL\n  };\n  Table.childContextTypes = columnInteractionBarContextTypes; // these default values for `resizeRowsByApproximateHeight` have been\n  // fine-tuned to work well with default Table font styles.\n\n  Table.resizeRowsByApproximateHeightDefaults = {\n    getApproximateCharWidth: 8,\n    getApproximateLineHeight: 18,\n    getCellHorizontalPadding: 2 * Locator.CELL_HORIZONTAL_PADDING,\n    getNumBufferLines: 1\n  };\n  Table.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST = [\"selectedRegions\"];\n  Table.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST = [\"selectedRegions\", \"viewportRect\"];\n  Table = Table_1 = tslib_1.__decorate([HotkeysTarget, polyfill], Table);\n  return Table;\n}(AbstractComponent2);\n\nexport { Table };\n\nfunction clampNumFrozenColumns(props) {\n  var numFrozenColumns = props.numFrozenColumns;\n  var numColumns = React.Children.count(props.children);\n  return clampPotentiallyNullValue(numFrozenColumns, numColumns);\n}\n\nfunction clampNumFrozenRows(props) {\n  var numFrozenRows = props.numFrozenRows,\n      numRows = props.numRows;\n  return clampPotentiallyNullValue(numFrozenRows, numRows);\n} // add explicit `| null | undefined`, because the params make more sense in this\n// order, and you can't have an optional param precede a required param.\n\n\nfunction clampPotentiallyNullValue(value, max) {\n  return value == null ? 0 : Utils.clamp(value, 0, max);\n}","map":null,"metadata":{},"sourceType":"module"}