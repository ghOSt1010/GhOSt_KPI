{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { AbstractComponent2, Utils as CoreUtils } from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport * as Classes from \"../common/classes\";\nimport * as ScrollUtils from \"../common/internal/scrollUtils\";\nimport { Utils } from \"../common/utils\";\nimport { QuadrantType, TableQuadrant } from \"./tableQuadrant\";\nimport { TableQuadrantStackCache } from \"./tableQuadrantStackCache\"; // when there are no column headers, the header and menu element will\n// confusingly collapse to zero height unless we establish this default.\n\nvar DEFAULT_COLUMN_HEADER_HEIGHT = 30; // the debounce delay for updating the view on scroll. elements will be resized\n// and rejiggered once scroll has ceased for at least this long, but not before.\n\nvar DEFAULT_VIEW_SYNC_DELAY = 500; // if there are no frozen rows or columns, we still want the quadrant to be 1px\n// bigger to reveal the header border. this border leaks into the cell grid to\n// ensure that selection overlay borders (e.g.) will be perfectly flush with it.\n\nvar QUADRANT_MIN_SIZE = 1; // a list of props that trigger layout changes. when these props change,\n// quadrant views need to be explicitly resynchronized.\n\nvar SYNC_TRIGGER_PROP_KEYS = [\"enableRowHeader\", \"loadingOptions\", \"numFrozenColumns\", \"numFrozenRows\", \"numColumns\", \"numRows\", \"enableColumnInteractionBar\"];\n\nvar TableQuadrantStack =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(TableQuadrantStack, _super); // Public\n  // ======\n\n\n  function TableQuadrantStack(props, context) {\n    var _a, _b;\n\n    var _this = _super.call(this, props, context) || this; // Instance variables\n    // ==================\n\n\n    _this.quadrantRefs = (_a = {}, _a[QuadrantType.MAIN] = {}, _a[QuadrantType.TOP] = {}, _a[QuadrantType.LEFT] = {}, _a[QuadrantType.TOP_LEFT] = {}, _a);\n    _this.quadrantRefHandlers = (_b = {}, _b[QuadrantType.MAIN] = _this.generateQuadrantRefHandlers(QuadrantType.MAIN), _b[QuadrantType.TOP] = _this.generateQuadrantRefHandlers(QuadrantType.TOP), _b[QuadrantType.LEFT] = _this.generateQuadrantRefHandlers(QuadrantType.LEFT), _b[QuadrantType.TOP_LEFT] = _this.generateQuadrantRefHandlers(QuadrantType.TOP_LEFT), _b); // this flag helps us avoid redundant work in the MAIN quadrant's onScroll callback, if the\n    // callback was triggered from a manual scrollTop/scrollLeft update within an onWheel.\n\n    _this.wasMainQuadrantScrollTriggeredByWheelEvent = false; // Quadrant-specific renderers\n    // ===========================\n    // Menu\n\n    _this.renderMainQuadrantMenu = function () {\n      return CoreUtils.safeInvoke(_this.props.menuRenderer, _this.quadrantRefHandlers[QuadrantType.MAIN].menu);\n    };\n\n    _this.renderTopQuadrantMenu = function () {\n      return CoreUtils.safeInvoke(_this.props.menuRenderer, _this.quadrantRefHandlers[QuadrantType.TOP].menu);\n    };\n\n    _this.renderLeftQuadrantMenu = function () {\n      return CoreUtils.safeInvoke(_this.props.menuRenderer, _this.quadrantRefHandlers[QuadrantType.LEFT].menu);\n    };\n\n    _this.renderTopLeftQuadrantMenu = function () {\n      return CoreUtils.safeInvoke(_this.props.menuRenderer, _this.quadrantRefHandlers[QuadrantType.TOP_LEFT].menu);\n    }; // Column header\n\n\n    _this.renderMainQuadrantColumnHeader = function (showFrozenColumnsOnly) {\n      var refHandler = _this.quadrantRefHandlers[QuadrantType.MAIN].columnHeader;\n      var resizeHandler = _this.handleColumnResizeGuideMain;\n      var reorderingHandler = _this.handleColumnsReordering;\n      return CoreUtils.safeInvoke(_this.props.columnHeaderCellRenderer, refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);\n    };\n\n    _this.renderTopQuadrantColumnHeader = function (showFrozenColumnsOnly) {\n      var refHandler = _this.quadrantRefHandlers[QuadrantType.TOP].columnHeader;\n      var resizeHandler = _this.handleColumnResizeGuideTop;\n      var reorderingHandler = _this.handleColumnsReordering;\n      return CoreUtils.safeInvoke(_this.props.columnHeaderCellRenderer, refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);\n    };\n\n    _this.renderLeftQuadrantColumnHeader = function (showFrozenColumnsOnly) {\n      var refHandler = _this.quadrantRefHandlers[QuadrantType.LEFT].columnHeader;\n      var resizeHandler = _this.handleColumnResizeGuideLeft;\n      var reorderingHandler = _this.handleColumnsReordering;\n      return CoreUtils.safeInvoke(_this.props.columnHeaderCellRenderer, refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);\n    };\n\n    _this.renderTopLeftQuadrantColumnHeader = function (showFrozenColumnsOnly) {\n      var refHandler = _this.quadrantRefHandlers[QuadrantType.TOP_LEFT].columnHeader;\n      var resizeHandler = _this.handleColumnResizeGuideTopLeft;\n      var reorderingHandler = _this.handleColumnsReordering;\n      return CoreUtils.safeInvoke(_this.props.columnHeaderCellRenderer, refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);\n    }; // Row header\n\n\n    _this.renderMainQuadrantRowHeader = function (showFrozenRowsOnly) {\n      var refHandler = _this.quadrantRefHandlers[QuadrantType.MAIN].rowHeader;\n      var resizeHandler = _this.handleRowResizeGuideMain;\n      var reorderingHandler = _this.handleRowsReordering;\n      return CoreUtils.safeInvoke(_this.props.rowHeaderCellRenderer, refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);\n    };\n\n    _this.renderTopQuadrantRowHeader = function (showFrozenRowsOnly) {\n      var refHandler = _this.quadrantRefHandlers[QuadrantType.TOP].rowHeader;\n      var resizeHandler = _this.handleRowResizeGuideTop;\n      var reorderingHandler = _this.handleRowsReordering;\n      return CoreUtils.safeInvoke(_this.props.rowHeaderCellRenderer, refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);\n    };\n\n    _this.renderLeftQuadrantRowHeader = function (showFrozenRowsOnly) {\n      var refHandler = _this.quadrantRefHandlers[QuadrantType.LEFT].rowHeader;\n      var resizeHandler = _this.handleRowResizeGuideLeft;\n      var reorderingHandler = _this.handleRowsReordering;\n      return CoreUtils.safeInvoke(_this.props.rowHeaderCellRenderer, refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);\n    };\n\n    _this.renderTopLeftQuadrantRowHeader = function (showFrozenRowsOnly) {\n      var refHandler = _this.quadrantRefHandlers[QuadrantType.TOP_LEFT].rowHeader;\n      var resizeHandler = _this.handleRowResizeGuideTopLeft;\n      var reorderingHandler = _this.handleRowsReordering;\n      return CoreUtils.safeInvoke(_this.props.rowHeaderCellRenderer, refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);\n    }; // Event handlers\n    // ==============\n    // Scrolling\n    // ---------\n\n\n    _this.handleMainQuadrantScroll = function (event) {\n      if (_this.wasMainQuadrantScrollTriggeredByWheelEvent) {\n        _this.wasMainQuadrantScrollTriggeredByWheelEvent = false;\n        return;\n      } // invoke onScroll - which may read current scroll position - before\n      // forcing a reflow with upcoming .scroll{Top,Left} setters.\n\n\n      CoreUtils.safeInvoke(_this.props.onScroll, event); // batch DOM reads here. note that onScroll events don't include deltas\n      // like onWheel events do, so we have to read from the DOM directly.\n\n      var mainScrollContainer = _this.quadrantRefs[QuadrantType.MAIN].scrollContainer;\n      var nextScrollLeft = mainScrollContainer.scrollLeft;\n      var nextScrollTop = mainScrollContainer.scrollTop; // with the \"scroll\" event, scroll offsets are updated prior to the\n      // event's firing, so no explicit update needed.\n\n      _this.handleScrollOffsetChange(\"scrollLeft\", nextScrollLeft);\n\n      _this.handleScrollOffsetChange(\"scrollTop\", nextScrollTop); // sync less important view stuff when scrolling/wheeling stops.\n\n\n      _this.syncQuadrantViewsDebounced();\n    };\n\n    _this.handleWheel = function (event) {\n      // again, let the listener read the current scroll position before we\n      // force a reflow by resizing or repositioning stuff.\n      CoreUtils.safeInvoke(_this.props.onScroll, event); // this helper performs DOM reads, so do them together before the writes below.\n\n      var nextScrollLeft = _this.getNextScrollOffset(\"horizontal\", event.deltaX);\n\n      var nextScrollTop = _this.getNextScrollOffset(\"vertical\", event.deltaY); // update this flag before updating the main quadrant scroll offsets,\n      // since we need this set before onScroll fires.\n\n\n      if (nextScrollLeft != null || nextScrollTop != null) {\n        _this.wasMainQuadrantScrollTriggeredByWheelEvent = true;\n      } // manually update the affected quadrant's scroll position to make sure\n      // it stays perfectly in sync with dependent quadrants in each frame.\n      // note: these DOM writes are batched together after the reads above.\n\n\n      _this.quadrantRefs[QuadrantType.MAIN].scrollContainer.scrollLeft = nextScrollLeft;\n      _this.quadrantRefs[QuadrantType.MAIN].scrollContainer.scrollTop = nextScrollTop;\n\n      _this.handleScrollOffsetChange(\"scrollLeft\", nextScrollLeft);\n\n      _this.handleScrollOffsetChange(\"scrollTop\", nextScrollTop); // sync less important view stuff when scrolling/wheeling stops.\n\n\n      _this.syncQuadrantViewsDebounced();\n    };\n\n    _this.getNextScrollOffset = function (direction, delta) {\n      var _a = _this.props,\n          grid = _a.grid,\n          isHorizontalScrollDisabled = _a.isHorizontalScrollDisabled,\n          isVerticalScrollDisabled = _a.isVerticalScrollDisabled;\n      var isHorizontal = direction === \"horizontal\";\n      var scrollKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n      var isScrollDisabled = isHorizontal ? isHorizontalScrollDisabled : isVerticalScrollDisabled;\n\n      if (isScrollDisabled) {\n        return undefined;\n      } // measure client size on the first event of the current wheel gesture,\n      // then grab cached values on successive events to eliminate DOM reads.\n      // requires clearing the cached values in the debounced view-update at\n      // the end of the wheel event.\n      // ASSUMPTION: the client size won't change during the wheel event.\n\n\n      var clientSize = isHorizontal ? _this.cache.getScrollContainerClientWidth() : _this.cache.getScrollContainerClientHeight();\n\n      if (clientSize == null) {\n        // should trigger only on the first scroll of the wheel gesture.\n        // will save client width and height sizes in the cache.\n        clientSize = _this.updateScrollContainerClientSize(isHorizontal);\n      } // by now, the client width and height will have been saved in cache, so\n      // they can't be nully anymore. also, events can only happen after\n      // mount, so we're guaranteed to have measured the header sizes in\n      // syncQuadrantViews() by now too, as it's invoked on mount.\n\n\n      var containerSize = isHorizontal ? _this.cache.getScrollContainerClientWidth() - _this.cache.getRowHeaderWidth() : _this.cache.getScrollContainerClientHeight() - _this.cache.getColumnHeaderHeight();\n      var gridSize = isHorizontal ? grid.getWidth() : grid.getHeight();\n      var maxScrollOffset = Math.max(0, gridSize - containerSize);\n\n      var currScrollOffset = _this.cache.getScrollOffset(scrollKey);\n\n      var nextScrollOffset = CoreUtils.clamp(currScrollOffset + delta, 0, maxScrollOffset);\n      return nextScrollOffset;\n    }; // Resizing\n    // --------\n    // Columns\n\n\n    _this.handleColumnResizeGuideMain = function (verticalGuides) {\n      _this.invokeColumnResizeHandler(verticalGuides, QuadrantType.MAIN);\n    };\n\n    _this.handleColumnResizeGuideTop = function (verticalGuides) {\n      _this.invokeColumnResizeHandler(verticalGuides, QuadrantType.TOP);\n    };\n\n    _this.handleColumnResizeGuideLeft = function (verticalGuides) {\n      _this.invokeColumnResizeHandler(verticalGuides, QuadrantType.LEFT);\n    };\n\n    _this.handleColumnResizeGuideTopLeft = function (verticalGuides) {\n      _this.invokeColumnResizeHandler(verticalGuides, QuadrantType.TOP_LEFT);\n    };\n\n    _this.invokeColumnResizeHandler = function (verticalGuides, quadrantType) {\n      var adjustedGuides = _this.adjustVerticalGuides(verticalGuides, quadrantType);\n\n      CoreUtils.safeInvoke(_this.props.handleColumnResizeGuide, adjustedGuides);\n    }; // Rows\n\n\n    _this.handleRowResizeGuideMain = function (horizontalGuides) {\n      _this.invokeRowResizeHandler(horizontalGuides, QuadrantType.MAIN);\n    };\n\n    _this.handleRowResizeGuideTop = function (horizontalGuides) {\n      _this.invokeRowResizeHandler(horizontalGuides, QuadrantType.TOP);\n    };\n\n    _this.handleRowResizeGuideLeft = function (horizontalGuides) {\n      _this.invokeRowResizeHandler(horizontalGuides, QuadrantType.LEFT);\n    };\n\n    _this.handleRowResizeGuideTopLeft = function (horizontalGuides) {\n      _this.invokeRowResizeHandler(horizontalGuides, QuadrantType.TOP_LEFT);\n    };\n\n    _this.invokeRowResizeHandler = function (horizontalGuides, quadrantType) {\n      var adjustedGuides = _this.adjustHorizontalGuides(horizontalGuides, quadrantType);\n\n      CoreUtils.safeInvoke(_this.props.handleRowResizeGuide, adjustedGuides);\n    }; // Reordering\n    // ----------\n    // Columns\n\n\n    _this.handleColumnsReordering = function (oldIndex, newIndex, length) {\n      var guideIndex = Utils.reorderedIndexToGuideIndex(oldIndex, newIndex, length);\n\n      var leftOffset = _this.props.grid.getCumulativeWidthBefore(guideIndex);\n\n      var quadrantType = guideIndex <= _this.props.numFrozenColumns ? QuadrantType.TOP_LEFT : QuadrantType.TOP;\n\n      var verticalGuides = _this.adjustVerticalGuides([leftOffset], quadrantType);\n\n      CoreUtils.safeInvoke(_this.props.handleColumnsReordering, verticalGuides);\n    }; // Rows\n\n\n    _this.handleRowsReordering = function (oldIndex, newIndex, length) {\n      var guideIndex = Utils.reorderedIndexToGuideIndex(oldIndex, newIndex, length);\n\n      var topOffset = _this.props.grid.getCumulativeHeightBefore(guideIndex);\n\n      var quadrantType = guideIndex <= _this.props.numFrozenRows ? QuadrantType.TOP_LEFT : QuadrantType.LEFT;\n\n      var horizontalGuides = _this.adjustHorizontalGuides([topOffset], quadrantType);\n\n      CoreUtils.safeInvoke(_this.props.handleRowsReordering, horizontalGuides);\n    }; // Size syncing\n    // ============\n\n\n    _this.syncQuadrantViewsDebounced = function () {\n      var viewSyncDelay = _this.props.viewSyncDelay;\n\n      if (viewSyncDelay < 0) {\n        // update synchronously\n        _this.syncQuadrantViews();\n      } else {\n        // update asynchronously after a debounced delay\n        clearInterval(_this.debouncedViewSyncInterval);\n        _this.debouncedViewSyncInterval = window.setTimeout(_this.syncQuadrantViews, viewSyncDelay);\n      }\n    };\n\n    _this.syncQuadrantViews = function () {\n      var mainRefs = _this.quadrantRefs[QuadrantType.MAIN];\n      var mainScrollContainer = mainRefs.scrollContainer; //\n      // Reads (batched to avoid DOM thrashing)\n      //\n\n      var rowHeaderWidth = _this.measureDesiredRowHeaderWidth();\n\n      var columnHeaderHeight = _this.measureDesiredColumnHeaderHeight();\n\n      var leftQuadrantGridWidth = _this.getSecondaryQuadrantGridSize(\"width\");\n\n      var topQuadrantGridHeight = _this.getSecondaryQuadrantGridSize(\"height\");\n\n      var leftQuadrantWidth = rowHeaderWidth + leftQuadrantGridWidth;\n      var topQuadrantHeight = columnHeaderHeight + topQuadrantGridHeight;\n      var rightScrollBarWidth = ScrollUtils.measureScrollBarThickness(mainScrollContainer, \"vertical\");\n      var bottomScrollBarHeight = ScrollUtils.measureScrollBarThickness(mainScrollContainer, \"horizontal\"); // ensure neither of these measurements confusingly clamps to zero height.\n\n      var adjustedColumnHeaderHeight = _this.maybeIncreaseToDefaultColumnHeaderHeight(columnHeaderHeight);\n\n      var adjustedTopQuadrantHeight = _this.maybeIncreaseToDefaultColumnHeaderHeight(topQuadrantHeight); // Update cache: let's read now whatever values we might need later.\n      // prevents unnecessary reflows in the future.\n\n\n      _this.cache.setRowHeaderWidth(rowHeaderWidth);\n\n      _this.cache.setColumnHeaderHeight(columnHeaderHeight); // ...however, we also clear the cached client size, so we can read it\n      // again when a new scroll begins. not safe to assume this won't change.\n      // TODO: maybe use the ResizeSensor?\n\n\n      _this.cache.setScrollContainerClientWidth(undefined);\n\n      _this.cache.setScrollContainerClientHeight(undefined); //\n      // Writes (batched to avoid DOM thrashing)\n      //\n      // Quadrant-size sync'ing: make the quadrants precisely as big as they\n      // need to be to fit their variable-sized headers and/or frozen areas.\n\n\n      _this.maybesSetQuadrantRowHeaderSizes(rowHeaderWidth);\n\n      _this.maybeSetQuadrantMenuElementSizes(rowHeaderWidth, adjustedColumnHeaderHeight);\n\n      _this.maybeSetQuadrantSizes(leftQuadrantWidth, adjustedTopQuadrantHeight); // Scrollbar clearance: tweak the quadrant bottom/right offsets to\n      // reveal the MAIN-quadrant scrollbars if they're visible.\n\n\n      _this.maybeSetQuadrantPositionOffset(QuadrantType.TOP, \"right\", rightScrollBarWidth);\n\n      _this.maybeSetQuadrantPositionOffset(QuadrantType.LEFT, \"bottom\", bottomScrollBarHeight); // Scroll syncing: sync the scroll offsets of quadrants that may or may\n      // not have been around prior to this update.\n\n\n      _this.maybeSetQuadrantScrollOffset(QuadrantType.LEFT, \"scrollTop\");\n\n      _this.maybeSetQuadrantScrollOffset(QuadrantType.TOP, \"scrollLeft\");\n    };\n\n    _this.maybeSetQuadrantSizes = function (width, height) {\n      _this.maybesSetQuadrantSize(QuadrantType.LEFT, \"width\", width);\n\n      _this.maybesSetQuadrantSize(QuadrantType.TOP, \"height\", height);\n\n      _this.maybesSetQuadrantSize(QuadrantType.TOP_LEFT, \"width\", width);\n\n      _this.maybesSetQuadrantSize(QuadrantType.TOP_LEFT, \"height\", height);\n    };\n\n    _this.maybesSetQuadrantSize = function (quadrantType, dimension, value) {\n      var quadrant = _this.quadrantRefs[quadrantType].quadrant;\n\n      if (quadrant != null) {\n        quadrant.style[dimension] = value + \"px\";\n      }\n    };\n\n    _this.maybeSetQuadrantPositionOffset = function (quadrantType, side, value) {\n      var quadrant = _this.quadrantRefs[quadrantType].quadrant;\n\n      if (quadrant != null) {\n        quadrant.style[side] = value + \"px\";\n      }\n    };\n\n    _this.maybesSetQuadrantRowHeaderSizes = function (width) {\n      _this.maybeSetQuadrantRowHeaderSize(QuadrantType.MAIN, width);\n\n      _this.maybeSetQuadrantRowHeaderSize(QuadrantType.TOP, width);\n\n      _this.maybeSetQuadrantRowHeaderSize(QuadrantType.LEFT, width);\n\n      _this.maybeSetQuadrantRowHeaderSize(QuadrantType.TOP_LEFT, width);\n    };\n\n    _this.maybeSetQuadrantRowHeaderSize = function (quadrantType, width) {\n      var rowHeader = _this.quadrantRefs[quadrantType].rowHeader;\n\n      if (rowHeader != null) {\n        rowHeader.style.width = width + \"px\";\n      }\n    };\n\n    _this.maybeSetQuadrantMenuElementSizes = function (width, height) {\n      _this.maybeSetQuadrantMenuElementSize(QuadrantType.MAIN, width, height);\n\n      _this.maybeSetQuadrantMenuElementSize(QuadrantType.TOP, width, height);\n\n      _this.maybeSetQuadrantMenuElementSize(QuadrantType.LEFT, width, height);\n\n      _this.maybeSetQuadrantMenuElementSize(QuadrantType.TOP_LEFT, width, height);\n    };\n\n    _this.maybeSetQuadrantMenuElementSize = function (quadrantType, width, height) {\n      var menu = _this.quadrantRefs[quadrantType].menu;\n\n      if (menu != null) {\n        menu.style.width = width + \"px\";\n        menu.style.height = height + \"px\";\n      }\n    };\n\n    _this.maybeSetQuadrantScrollOffset = function (quadrantType, scrollKey, newOffset) {\n      var scrollContainer = _this.quadrantRefs[quadrantType].scrollContainer;\n      var scrollOffset = newOffset != null ? newOffset : _this.cache.getScrollOffset(scrollKey);\n\n      if (scrollContainer != null) {\n        scrollContainer[scrollKey] = scrollOffset;\n      }\n    };\n\n    _this.handleScrollOffsetChange = function (scrollKey, offset) {\n      _this.cache.setScrollOffset(scrollKey, offset);\n\n      var dependentQuadrantType = scrollKey === \"scrollLeft\" ? QuadrantType.TOP : QuadrantType.LEFT;\n\n      _this.maybeSetQuadrantScrollOffset(dependentQuadrantType, scrollKey);\n    }; // callbacks trigger too frequently unless we throttle scroll and wheel\n    // events. declare these functions on the component instance since\n    // they're stateful.\n\n\n    _this.throttledHandleMainQuadrantScroll = CoreUtils.throttleReactEventCallback(_this.handleMainQuadrantScroll);\n    _this.throttledHandleWheel = CoreUtils.throttleReactEventCallback(_this.handleWheel);\n    _this.cache = new TableQuadrantStackCache();\n    return _this;\n  }\n  /**\n   * Scroll the main quadrant to the specified scroll offset, keeping all other quadrants in sync.\n   */\n\n\n  TableQuadrantStack.prototype.scrollToPosition = function (scrollLeft, scrollTop) {\n    var scrollContainer = this.quadrantRefs[QuadrantType.MAIN].scrollContainer;\n    this.wasMainQuadrantScrollTriggeredByWheelEvent = false; // this will trigger the main quadrant's scroll callback below\n\n    scrollContainer.scrollLeft = scrollLeft;\n    scrollContainer.scrollTop = scrollTop;\n    this.syncQuadrantViews();\n  };\n  /**\n   * Synchronizes quadrant sizes and scroll offsets based on the current\n   * column, row, and header sizes. Useful for correcting quadrant sizes after\n   * explicitly resizing columns and rows, for instance.\n   *\n   * Invoking this method imperatively is cheaper than providing columnWidths\n   * or rowHeights array props to TableQuadrantStack and forcing it to run\n   * expensive array diffs upon every update.\n   */\n\n\n  TableQuadrantStack.prototype.synchronizeQuadrantViews = function () {\n    this.syncQuadrantViews();\n  };\n\n  TableQuadrantStack.prototype.componentDidMount = function () {\n    this.emitRefs();\n    this.syncQuadrantViews();\n  };\n\n  TableQuadrantStack.prototype.componentDidUpdate = function (prevProps) {\n    // sync'ing quadrant views triggers expensive reflows, so we only call\n    // it when layout-affecting props change.\n    if (!CoreUtils.shallowCompareKeys(this.props, prevProps, {\n      include: SYNC_TRIGGER_PROP_KEYS\n    })) {\n      this.emitRefs();\n      this.syncQuadrantViews();\n    }\n  };\n\n  TableQuadrantStack.prototype.render = function () {\n    var _a = this.props,\n        grid = _a.grid,\n        enableRowHeader = _a.enableRowHeader,\n        bodyRenderer = _a.bodyRenderer,\n        throttleScrolling = _a.throttleScrolling; // use the more generic \"scroll\" event for the main quadrant to capture\n    // *both* scrollbar interactions and trackpad/mousewheel gestures.\n\n    var onMainQuadrantScroll = throttleScrolling ? this.throttledHandleMainQuadrantScroll : this.handleMainQuadrantScroll;\n    var onWheel = throttleScrolling ? this.throttledHandleWheel : this.handleWheel;\n    var baseProps = {\n      bodyRenderer: bodyRenderer,\n      enableRowHeader: enableRowHeader,\n      grid: grid,\n      onWheel: onWheel\n    };\n    var shouldRenderLeftQuadrants = this.shouldRenderLeftQuadrants();\n    var maybeLeftQuadrant = shouldRenderLeftQuadrants ? React.createElement(TableQuadrant, tslib_1.__assign({}, baseProps, {\n      quadrantRef: this.quadrantRefHandlers[QuadrantType.LEFT].quadrant,\n      quadrantType: QuadrantType.LEFT,\n      columnHeaderCellRenderer: this.renderLeftQuadrantColumnHeader,\n      menuRenderer: this.renderLeftQuadrantMenu,\n      rowHeaderCellRenderer: this.renderLeftQuadrantRowHeader,\n      scrollContainerRef: this.quadrantRefHandlers[QuadrantType.LEFT].scrollContainer\n    })) : undefined;\n    var maybeTopLeftQuadrant = shouldRenderLeftQuadrants ? React.createElement(TableQuadrant, tslib_1.__assign({}, baseProps, {\n      quadrantRef: this.quadrantRefHandlers[QuadrantType.TOP_LEFT].quadrant,\n      quadrantType: QuadrantType.TOP_LEFT,\n      columnHeaderCellRenderer: this.renderTopLeftQuadrantColumnHeader,\n      menuRenderer: this.renderTopLeftQuadrantMenu,\n      rowHeaderCellRenderer: this.renderTopLeftQuadrantRowHeader,\n      scrollContainerRef: this.quadrantRefHandlers[QuadrantType.TOP_LEFT].scrollContainer\n    })) : undefined;\n    return React.createElement(\"div\", {\n      className: Classes.TABLE_QUADRANT_STACK\n    }, React.createElement(TableQuadrant, tslib_1.__assign({}, baseProps, {\n      bodyRef: this.props.bodyRef,\n      onScroll: onMainQuadrantScroll,\n      quadrantRef: this.quadrantRefHandlers[QuadrantType.MAIN].quadrant,\n      quadrantType: QuadrantType.MAIN,\n      columnHeaderCellRenderer: this.renderMainQuadrantColumnHeader,\n      menuRenderer: this.renderMainQuadrantMenu,\n      rowHeaderCellRenderer: this.renderMainQuadrantRowHeader,\n      scrollContainerRef: this.quadrantRefHandlers[QuadrantType.MAIN].scrollContainer\n    })), React.createElement(TableQuadrant, tslib_1.__assign({}, baseProps, {\n      quadrantRef: this.quadrantRefHandlers[QuadrantType.TOP].quadrant,\n      quadrantType: QuadrantType.TOP,\n      columnHeaderCellRenderer: this.renderTopQuadrantColumnHeader,\n      menuRenderer: this.renderTopQuadrantMenu,\n      rowHeaderCellRenderer: this.renderTopQuadrantRowHeader,\n      scrollContainerRef: this.quadrantRefHandlers[QuadrantType.TOP].scrollContainer\n    })), maybeLeftQuadrant, maybeTopLeftQuadrant);\n  }; // Ref handlers\n  // ============\n\n\n  TableQuadrantStack.prototype.generateQuadrantRefHandlers = function (quadrantType) {\n    var _this = this;\n\n    var reducer = function reducer(agg, key) {\n      agg[key] = function (ref) {\n        return _this.quadrantRefs[quadrantType][key] = ref;\n      };\n\n      return agg;\n    };\n\n    return [\"columnHeader\", \"menu\", \"quadrant\", \"rowHeader\", \"scrollContainer\"].reduce(reducer, {});\n  }; // Emitters\n  // ========\n\n\n  TableQuadrantStack.prototype.emitRefs = function () {\n    CoreUtils.safeInvoke(this.props.quadrantRef, this.quadrantRefs[QuadrantType.MAIN].quadrant);\n    CoreUtils.safeInvoke(this.props.rowHeaderRef, this.quadrantRefs[QuadrantType.MAIN].rowHeader);\n    CoreUtils.safeInvoke(this.props.columnHeaderRef, this.quadrantRefs[QuadrantType.MAIN].columnHeader);\n    CoreUtils.safeInvoke(this.props.scrollContainerRef, this.quadrantRefs[QuadrantType.MAIN].scrollContainer);\n  }; // this function is named 'update' instead of 'set', because a 'set'\n  // function typically takes the new value as a parameter. we avoid that to\n  // keep the isHorizontal logic tree contained within this function.\n\n\n  TableQuadrantStack.prototype.updateScrollContainerClientSize = function (isHorizontal) {\n    var mainScrollContainer = this.quadrantRefs[QuadrantType.MAIN].scrollContainer;\n\n    if (isHorizontal) {\n      this.cache.setScrollContainerClientWidth(mainScrollContainer.clientWidth);\n      return this.cache.getScrollContainerClientWidth();\n    } else {\n      this.cache.setScrollContainerClientHeight(mainScrollContainer.clientHeight);\n      return this.cache.getScrollContainerClientHeight();\n    }\n  };\n\n  TableQuadrantStack.prototype.maybeIncreaseToDefaultColumnHeaderHeight = function (height) {\n    return height <= QUADRANT_MIN_SIZE ? DEFAULT_COLUMN_HEADER_HEIGHT : height;\n  }; // Helpers\n  // =======\n\n  /**\n   * Returns the width or height of *only the grid* in the secondary quadrants\n   * (TOP, LEFT, TOP_LEFT), based on the number of frozen rows and columns.\n   */\n\n\n  TableQuadrantStack.prototype.getSecondaryQuadrantGridSize = function (dimension) {\n    var _a = this.props,\n        grid = _a.grid,\n        numFrozenColumns = _a.numFrozenColumns,\n        numFrozenRows = _a.numFrozenRows;\n    var numFrozen = dimension === \"width\" ? numFrozenColumns : numFrozenRows;\n    var getterFn = dimension === \"width\" ? grid.getCumulativeWidthAt : grid.getCumulativeHeightAt; // both getter functions do O(1) lookups.\n\n    return numFrozen > 0 ? getterFn(numFrozen - 1) : QUADRANT_MIN_SIZE;\n  };\n  /**\n   * Measures the desired width of the row header based on its tallest\n   * contents.\n   */\n\n\n  TableQuadrantStack.prototype.measureDesiredRowHeaderWidth = function () {\n    // the MAIN row header serves as the source of truth\n    var mainRowHeader = this.quadrantRefs[QuadrantType.MAIN].rowHeader;\n\n    if (mainRowHeader == null) {\n      return 0;\n    } else {\n      // (alas, we must force a reflow to measure the row header's \"desired\" width)\n      mainRowHeader.style.width = \"auto\";\n      var desiredRowHeaderWidth = mainRowHeader.clientWidth;\n      return desiredRowHeaderWidth;\n    }\n  };\n  /**\n   * Measures the desired height of the column header based on its tallest\n   * contents.\n   */\n\n\n  TableQuadrantStack.prototype.measureDesiredColumnHeaderHeight = function () {\n    // unlike the row headers, the column headers are in a display-flex\n    // layout and are not actually bound by any fixed `height` that we set,\n    // so they'll grow freely to their necessary size. makes measuring easy!\n    var mainColumnHeader = this.quadrantRefs[QuadrantType.MAIN].columnHeader;\n    return mainColumnHeader == null ? 0 : mainColumnHeader.clientHeight;\n  };\n\n  TableQuadrantStack.prototype.shouldRenderLeftQuadrants = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var enableRowHeader = props.enableRowHeader,\n        numFrozenColumns = props.numFrozenColumns;\n    return enableRowHeader || numFrozenColumns != null && numFrozenColumns > 0;\n  }; // Resizing\n\n\n  TableQuadrantStack.prototype.adjustVerticalGuides = function (verticalGuides, quadrantType) {\n    var isFrozenQuadrant = quadrantType === QuadrantType.LEFT || quadrantType === QuadrantType.TOP_LEFT;\n    var scrollAmount = isFrozenQuadrant ? 0 : this.cache.getScrollOffset(\"scrollLeft\");\n    var rowHeaderWidth = this.cache.getRowHeaderWidth();\n    var adjustedVerticalGuides = verticalGuides != null ? verticalGuides.map(function (verticalGuide) {\n      return verticalGuide - scrollAmount + rowHeaderWidth;\n    }) : verticalGuides;\n    return adjustedVerticalGuides;\n  };\n\n  TableQuadrantStack.prototype.adjustHorizontalGuides = function (horizontalGuides, quadrantType) {\n    var isFrozenQuadrant = quadrantType === QuadrantType.TOP || quadrantType === QuadrantType.TOP_LEFT;\n    var scrollAmount = isFrozenQuadrant ? 0 : this.cache.getScrollOffset(\"scrollTop\");\n    var columnHeaderHeight = this.cache.getColumnHeaderHeight();\n    var adjustedHorizontalGuides = horizontalGuides != null ? horizontalGuides.map(function (horizontalGuide) {\n      return horizontalGuide - scrollAmount + columnHeaderHeight;\n    }) : horizontalGuides;\n    return adjustedHorizontalGuides;\n  }; // we want the user to explicitly pass a quadrantType. define defaultProps as a Partial to avoid\n  // declaring that and other required props here.\n\n\n  TableQuadrantStack.defaultProps = {\n    enableColumnInteractionBar: undefined,\n    enableRowHeader: true,\n    isHorizontalScrollDisabled: false,\n    isVerticalScrollDisabled: false,\n    throttleScrolling: true,\n    viewSyncDelay: DEFAULT_VIEW_SYNC_DELAY\n  };\n  TableQuadrantStack = tslib_1.__decorate([polyfill], TableQuadrantStack);\n  return TableQuadrantStack;\n}(AbstractComponent2);\n\nexport { TableQuadrantStack };","map":null,"metadata":{},"sourceType":"module"}