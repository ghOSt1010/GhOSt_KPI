{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { Icon, Utils as CoreUtils } from \"@blueprintjs/core\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport * as Classes from \"../common/classes\";\nimport { DragEvents } from \"../interactions/dragEvents\";\nimport { DragReorderable } from \"../interactions/reorderable\";\nimport { Resizable } from \"../interactions/resizable\";\nimport { DragSelectable } from \"../interactions/selectable\";\nimport { RegionCardinality, Regions } from \"../regions\";\nvar SHALLOW_COMPARE_PROP_KEYS_BLACKLIST = [\"focusedCell\", \"selectedRegions\"];\n\nvar Header =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Header, _super);\n\n  function Header(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.convertEventToIndex = function (event) {\n      var coord = _this.props.getMouseCoordinate(event);\n\n      return _this.props.convertPointToIndex(coord);\n    };\n\n    _this.locateClick = function (event) {\n      _this.activationIndex = _this.convertEventToIndex(event);\n      return _this.props.toRegion(_this.activationIndex);\n    };\n\n    _this.locateDragForSelection = function (_event, coords, returnEndOnly) {\n      if (returnEndOnly === void 0) {\n        returnEndOnly = false;\n      }\n\n      var coord = _this.props.getDragCoordinate(coords.current);\n\n      var indexStart = _this.activationIndex;\n\n      var indexEnd = _this.props.convertPointToIndex(coord);\n\n      return returnEndOnly ? _this.props.toRegion(indexEnd) : _this.props.toRegion(indexStart, indexEnd);\n    };\n\n    _this.locateDragForReordering = function (_event, coords) {\n      var coord = _this.props.getDragCoordinate(coords.current);\n\n      var guideIndex = _this.props.convertPointToIndex(coord, true);\n\n      return guideIndex < 0 ? undefined : guideIndex;\n    };\n\n    _this.renderCells = function () {\n      var _a = _this.props,\n          indexStart = _a.indexStart,\n          indexEnd = _a.indexEnd;\n      var cells = [];\n\n      for (var index = indexStart; index <= indexEnd; index++) {\n        cells.push(_this.renderNewCell(index));\n      }\n\n      return cells;\n    };\n\n    _this.renderNewCell = function (index) {\n      var extremaClasses = _this.props.getCellExtremaClasses(index, _this.props.indexEnd);\n\n      var renderer = _this.props.isGhostIndex(index) ? _this.props.ghostCellRenderer : _this.renderCell;\n      return renderer(index, extremaClasses);\n    };\n\n    _this.renderCell = function (index, extremaClasses) {\n      var _a, _b;\n\n      var _c = _this.props,\n          getIndexClass = _c.getIndexClass,\n          selectedRegions = _c.selectedRegions;\n\n      var cell = _this.props.headerCellRenderer(index);\n\n      if (cell == null) {\n        return null;\n      }\n\n      var isLoading = cell.props.loading != null ? cell.props.loading : _this.props.loading;\n\n      var isSelected = _this.props.isCellSelected(index);\n\n      var isEntireCellTargetReorderable = _this.isEntireCellTargetReorderable(index);\n\n      var className = classNames(extremaClasses, (_a = {}, _a[Classes.TABLE_HEADER_REORDERABLE] = isEntireCellTargetReorderable, _a), _this.props.getCellIndexClass(index), cell.props.className);\n      var cellProps = (_b = {\n        className: className,\n        index: index\n      }, _b[_this.props.headerCellIsSelectedPropName] = isSelected, _b[_this.props.headerCellIsReorderablePropName] = isEntireCellTargetReorderable, _b.loading = isLoading, _b.reorderHandle = _this.maybeRenderReorderHandle(index), _b);\n\n      var modifiedHandleSizeChanged = function modifiedHandleSizeChanged(size) {\n        return _this.props.handleSizeChanged(index, size);\n      };\n\n      var modifiedHandleResizeEnd = function modifiedHandleResizeEnd(size) {\n        return _this.props.handleResizeEnd(index, size);\n      };\n\n      var modifiedHandleResizeHandleDoubleClick = function modifiedHandleResizeHandleDoubleClick() {\n        return CoreUtils.safeInvoke(_this.props.handleResizeDoubleClick, index);\n      };\n\n      var baseChildren = React.createElement(DragSelectable, {\n        enableMultipleSelection: _this.props.enableMultipleSelection,\n        disabled: _this.isDragSelectableDisabled,\n        focusedCell: _this.props.focusedCell,\n        ignoredSelectors: [\".\" + Classes.TABLE_REORDER_HANDLE_TARGET],\n        key: getIndexClass(index),\n        locateClick: _this.locateClick,\n        locateDrag: _this.locateDragForSelection,\n        onFocusedCell: _this.props.onFocusedCell,\n        onSelection: _this.handleDragSelectableSelection,\n        onSelectionEnd: _this.handleDragSelectableSelectionEnd,\n        selectedRegions: selectedRegions,\n        selectedRegionTransform: _this.props.selectedRegionTransform\n      }, React.createElement(Resizable, {\n        isResizable: _this.props.isResizable,\n        maxSize: _this.props.maxSize,\n        minSize: _this.props.minSize,\n        onDoubleClick: modifiedHandleResizeHandleDoubleClick,\n        onLayoutLock: _this.props.onLayoutLock,\n        onResizeEnd: modifiedHandleResizeEnd,\n        onSizeChanged: modifiedHandleSizeChanged,\n        orientation: _this.props.resizeOrientation,\n        size: _this.props.getCellSize(index)\n      }, React.cloneElement(cell, cellProps)));\n      return _this.isReorderHandleEnabled() ? baseChildren // reordering will be handled by interacting with the reorder handle\n      : _this.wrapInDragReorderable(index, baseChildren, _this.isDragReorderableDisabled);\n    };\n\n    _this.handleDragSelectableSelection = function (selectedRegions) {\n      _this.props.onSelection(selectedRegions);\n\n      _this.setState({\n        hasValidSelection: false\n      });\n    };\n\n    _this.handleDragSelectableSelectionEnd = function () {\n      _this.activationIndex = null; // not strictly required, but good practice\n\n      _this.setState({\n        hasValidSelection: true\n      });\n    };\n\n    _this.isDragSelectableDisabled = function (event) {\n      if (DragEvents.isAdditive(event)) {\n        // if the meta/ctrl key was pressed, we want to forcefully ignore\n        // reordering interactions and prioritize drag-selection\n        // interactions (e.g. to make it possible to deselect a row).\n        return false;\n      }\n\n      var cellIndex = _this.convertEventToIndex(event);\n\n      return _this.isEntireCellTargetReorderable(cellIndex);\n    };\n\n    _this.isDragReorderableDisabled = function (event) {\n      var isSelectionEnabled = !_this.isDragSelectableDisabled(event);\n\n      if (isSelectionEnabled) {\n        // if drag-selection is enabled, we don't want drag-reordering\n        // interactions to compete. otherwise, a mouse-drag might both expand a\n        // selection and reorder the same selection simultaneously - confusing!\n        return true;\n      }\n\n      var cellIndex = _this.convertEventToIndex(event);\n\n      return !_this.isEntireCellTargetReorderable(cellIndex);\n    };\n\n    _this.isEntireCellTargetReorderable = function (index) {\n      var selectedRegions = _this.props.selectedRegions; // although reordering may be generally enabled for this row/column (via props.isReorderable), the\n      // row/column shouldn't actually become reorderable from a user perspective until a few other\n      // conditions are true:\n\n      return _this.props.isReorderable && // the row/column should be the only selection (or it should be part of the only selection),\n      // because reordering multiple disjoint row/column selections is a UX morass with no clear best\n      // behavior.\n      _this.props.isCellSelected(index) && _this.state.hasValidSelection && Regions.getRegionCardinality(selectedRegions[0]) === _this.props.fullRegionCardinality && // selected regions can be updated during mousedown+drag and before mouseup; thus, we\n      // add a final check to make sure we don't enable reordering until the selection\n      // interaction is complete. this prevents one click+drag interaction from triggering\n      // both selection and reordering behavior.\n      selectedRegions.length === 1 && // columns are reordered via a reorder handle, so drag-selection needn't be disabled\n      !_this.isReorderHandleEnabled();\n    };\n\n    _this.state = {\n      hasValidSelection: _this.isSelectedRegionsControlledAndNonEmpty(props)\n    };\n    return _this;\n  }\n\n  Header.prototype.componentDidUpdate = function (_, prevState) {\n    var nextHasValidSection = this.isSelectedRegionsControlledAndNonEmpty(this.props);\n\n    if (prevState.hasValidSelection !== nextHasValidSection) {\n      this.setState({\n        hasValidSelection: nextHasValidSection\n      });\n    }\n  };\n\n  Header.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    return !CoreUtils.shallowCompareKeys(this.state, nextState) || !CoreUtils.shallowCompareKeys(this.props, nextProps, {\n      exclude: SHALLOW_COMPARE_PROP_KEYS_BLACKLIST\n    }) || !CoreUtils.deepCompareKeys(this.props, nextProps, SHALLOW_COMPARE_PROP_KEYS_BLACKLIST);\n  };\n\n  Header.prototype.render = function () {\n    return this.props.wrapCells(this.renderCells());\n  };\n\n  Header.prototype.isSelectedRegionsControlledAndNonEmpty = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    return props.selectedRegions != null && props.selectedRegions.length > 0;\n  };\n\n  Header.prototype.isReorderHandleEnabled = function () {\n    // the reorder handle can only appear in the column interaction bar\n    return this.isColumnHeader() && this.props.isReorderable;\n  };\n\n  Header.prototype.maybeRenderReorderHandle = function (index) {\n    return !this.isReorderHandleEnabled() ? undefined : this.wrapInDragReorderable(index, React.createElement(\"div\", {\n      className: Classes.TABLE_REORDER_HANDLE_TARGET\n    }, React.createElement(\"div\", {\n      className: Classes.TABLE_REORDER_HANDLE\n    }, React.createElement(Icon, {\n      icon: \"drag-handle-vertical\"\n    }))), false);\n  };\n\n  Header.prototype.isColumnHeader = function () {\n    return this.props.fullRegionCardinality === RegionCardinality.FULL_COLUMNS;\n  };\n\n  Header.prototype.wrapInDragReorderable = function (index, children, disabled) {\n    return React.createElement(DragReorderable, {\n      disabled: disabled,\n      key: this.props.getIndexClass(index),\n      locateClick: this.locateClick,\n      locateDrag: this.locateDragForReordering,\n      onReordered: this.props.onReordered,\n      onReordering: this.props.onReordering,\n      onSelection: this.props.onSelection,\n      onFocusedCell: this.props.onFocusedCell,\n      selectedRegions: this.props.selectedRegions,\n      toRegion: this.props.toRegion\n    }, children);\n  };\n\n  return Header;\n}(React.Component);\n\nexport { Header };","map":null,"metadata":{},"sourceType":"module"}