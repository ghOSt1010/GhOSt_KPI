{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as Classes from \"./common/classes\";\nimport { Utils } from \"./common/utils\";\n/**\n * `Region`s contain sets of cells. Additionally, a distinction is drawn, for\n * example, between all cells within a column and the whole column itself.\n * The `RegionCardinality` enum represents these distinct types of `Region`s.\n */\n\nexport var RegionCardinality;\n\n(function (RegionCardinality) {\n  /**\n   * A region that contains a finite rectangular group of table cells\n   */\n  RegionCardinality[\"CELLS\"] = \"cells\";\n  /**\n   * A region that represents all cells within 1 or more rows.\n   */\n\n  RegionCardinality[\"FULL_ROWS\"] = \"full-rows\";\n  /**\n   * A region that represents all cells within 1 or more columns.\n   */\n\n  RegionCardinality[\"FULL_COLUMNS\"] = \"full-columns\";\n  /**\n   * A region that represents all cells in the table.\n   */\n\n  RegionCardinality[\"FULL_TABLE\"] = \"full-table\";\n})(RegionCardinality || (RegionCardinality = {}));\n/**\n * A convenience object for subsets of `RegionCardinality` that are commonly\n * used as the `selectionMode` prop of the `<Table>`.\n */\n\n\nexport var SelectionModes = {\n  ALL: [RegionCardinality.FULL_TABLE, RegionCardinality.FULL_COLUMNS, RegionCardinality.FULL_ROWS, RegionCardinality.CELLS],\n  COLUMNS_AND_CELLS: [RegionCardinality.FULL_COLUMNS, RegionCardinality.CELLS],\n  COLUMNS_ONLY: [RegionCardinality.FULL_COLUMNS],\n  NONE: [],\n  ROWS_AND_CELLS: [RegionCardinality.FULL_ROWS, RegionCardinality.CELLS],\n  ROWS_ONLY: [RegionCardinality.FULL_ROWS]\n};\nexport var ColumnLoadingOption;\n\n(function (ColumnLoadingOption) {\n  ColumnLoadingOption[\"CELLS\"] = \"cells\";\n  ColumnLoadingOption[\"HEADER\"] = \"column-header\";\n})(ColumnLoadingOption || (ColumnLoadingOption = {}));\n\nexport var RowLoadingOption;\n\n(function (RowLoadingOption) {\n  RowLoadingOption[\"CELLS\"] = \"cells\";\n  RowLoadingOption[\"HEADER\"] = \"row-header\";\n})(RowLoadingOption || (RowLoadingOption = {}));\n\nexport var TableLoadingOption;\n\n(function (TableLoadingOption) {\n  TableLoadingOption[\"CELLS\"] = \"cells\";\n  TableLoadingOption[\"COLUMN_HEADERS\"] = \"column-header\";\n  TableLoadingOption[\"ROW_HEADERS\"] = \"row-header\";\n})(TableLoadingOption || (TableLoadingOption = {}));\n\nvar Regions =\n/** @class */\nfunction () {\n  function Regions() {}\n  /**\n   * Determines the cardinality of a region. We use null values to indicate\n   * an unbounded interval. Therefore, an example of a region containing the\n   * second and third columns would be:\n   *\n   * ```js\n   * { rows: null, cols: [1, 2] }\n   * ```\n   *\n   * In this case, this method would return `RegionCardinality.FULL_COLUMNS`.\n   *\n   * If both rows and columns are unbounded, then the region covers the\n   * entire table. Therefore, a region like this:\n   *\n   * ```js\n   * { rows: null, cols: null }\n   * ```\n   *\n   * will return `RegionCardinality.FULL_TABLE`.\n   *\n   * An example of a region containing a single cell in the table would be:\n   *\n   * ```js\n   * { rows: [5, 5], cols: [2, 2] }\n   * ```\n   *\n   * In this case, this method would return `RegionCardinality.CELLS`.\n   */\n\n\n  Regions.getRegionCardinality = function (region) {\n    if (region.cols != null && region.rows != null) {\n      return RegionCardinality.CELLS;\n    } else if (region.cols != null) {\n      return RegionCardinality.FULL_COLUMNS;\n    } else if (region.rows != null) {\n      return RegionCardinality.FULL_ROWS;\n    } else {\n      return RegionCardinality.FULL_TABLE;\n    }\n  };\n\n  Regions.getFocusCellCoordinatesFromRegion = function (region) {\n    var regionCardinality = Regions.getRegionCardinality(region);\n\n    switch (regionCardinality) {\n      case RegionCardinality.FULL_TABLE:\n        return {\n          col: 0,\n          row: 0\n        };\n\n      case RegionCardinality.FULL_COLUMNS:\n        return {\n          col: region.cols[0],\n          row: 0\n        };\n\n      case RegionCardinality.FULL_ROWS:\n        return {\n          col: 0,\n          row: region.rows[0]\n        };\n\n      case RegionCardinality.CELLS:\n        return {\n          col: region.cols[0],\n          row: region.rows[0]\n        };\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Returns a deep copy of the provided region.\n   */\n\n\n  Regions.copy = function (region) {\n    var cardinality = Regions.getRegionCardinality(region); // we need to be careful not to explicitly spell out `rows: undefined`\n    // (e.g.) if the \"rows\" key is completely absent, otherwise\n    // deep-equality checks will fail.\n\n    if (cardinality === RegionCardinality.CELLS) {\n      return Regions.cell(region.rows[0], region.cols[0], region.rows[1], region.cols[1]);\n    } else if (cardinality === RegionCardinality.FULL_COLUMNS) {\n      return Regions.column(region.cols[0], region.cols[1]);\n    } else if (cardinality === RegionCardinality.FULL_ROWS) {\n      return Regions.row(region.rows[0], region.rows[1]);\n    } else {\n      return Regions.table();\n    }\n  };\n  /**\n   * Returns a region containing one or more cells.\n   */\n\n\n  Regions.cell = function (row, col, row2, col2) {\n    return {\n      cols: this.normalizeInterval(col, col2),\n      rows: this.normalizeInterval(row, row2)\n    };\n  };\n  /**\n   * Returns a region containing one or more full rows.\n   */\n\n\n  Regions.row = function (row, row2) {\n    return {\n      rows: this.normalizeInterval(row, row2)\n    };\n  };\n  /**\n   * Returns a region containing one or more full columns.\n   */\n\n\n  Regions.column = function (col, col2) {\n    return {\n      cols: this.normalizeInterval(col, col2)\n    };\n  };\n  /**\n   * Returns a region containing the entire table.\n   */\n\n\n  Regions.table = function () {\n    return {};\n  };\n  /**\n   * Adds the region to the end of a cloned copy of the supplied region\n   * array.\n   */\n\n\n  Regions.add = function (regions, region) {\n    var copy = regions.slice();\n    copy.push(region);\n    return copy;\n  };\n  /**\n   * Replaces the region at the end of a cloned copy of the supplied region\n   * array, or at the specific index if one is provided.\n   */\n\n\n  Regions.update = function (regions, region, index) {\n    var copy = regions.slice();\n\n    if (index != null) {\n      copy.splice(index, 1, region);\n    } else {\n      copy.pop();\n      copy.push(region);\n    }\n\n    return copy;\n  };\n  /**\n   * Clamps the region's start and end indices between 0 and the provided\n   * maximum values.\n   */\n\n\n  Regions.clampRegion = function (region, maxRowIndex, maxColumnIndex) {\n    var nextRegion = Regions.copy(region);\n\n    if (region.rows != null) {\n      nextRegion.rows[0] = Utils.clamp(region.rows[0], 0, maxRowIndex);\n      nextRegion.rows[1] = Utils.clamp(region.rows[1], 0, maxRowIndex);\n    }\n\n    if (region.cols != null) {\n      nextRegion.cols[0] = Utils.clamp(region.cols[0], 0, maxColumnIndex);\n      nextRegion.cols[1] = Utils.clamp(region.cols[1], 0, maxColumnIndex);\n    }\n\n    return nextRegion;\n  };\n  /**\n   * Returns true iff the specified region is equal to the last region in\n   * the region list. This allows us to avoid immediate additive re-selection.\n   */\n\n\n  Regions.lastRegionIsEqual = function (regions, region) {\n    if (regions == null || regions.length === 0) {\n      return false;\n    }\n\n    var lastRegion = regions[regions.length - 1];\n    return Regions.regionsEqual(lastRegion, region);\n  };\n  /**\n   * Returns the index of the region that is equal to the supplied\n   * parameter. Returns -1 if no such region is found.\n   */\n\n\n  Regions.findMatchingRegion = function (regions, region) {\n    if (regions == null) {\n      return -1;\n    }\n\n    for (var i = 0; i < regions.length; i++) {\n      if (Regions.regionsEqual(regions[i], region)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Returns the index of the region that wholly contains the supplied\n   * parameter. Returns -1 if no such region is found.\n   */\n\n\n  Regions.findContainingRegion = function (regions, region) {\n    if (regions == null) {\n      return -1;\n    }\n\n    for (var i = 0; i < regions.length; i++) {\n      if (Regions.regionContains(regions[i], region)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Returns true if the regions contain a region that has FULL_COLUMNS\n   * cardinality and contains the specified column index.\n   */\n\n\n  Regions.hasFullColumn = function (regions, col) {\n    if (regions == null) {\n      return false;\n    }\n\n    for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {\n      var region = regions_1[_i];\n      var cardinality = Regions.getRegionCardinality(region);\n\n      if (cardinality === RegionCardinality.FULL_TABLE) {\n        return true;\n      }\n\n      if (cardinality === RegionCardinality.FULL_COLUMNS && Regions.intervalContainsIndex(region.cols, col)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if the regions contain a region that has FULL_ROWS\n   * cardinality and contains the specified row index.\n   */\n\n\n  Regions.hasFullRow = function (regions, row) {\n    if (regions == null) {\n      return false;\n    }\n\n    for (var _i = 0, regions_2 = regions; _i < regions_2.length; _i++) {\n      var region = regions_2[_i];\n      var cardinality = Regions.getRegionCardinality(region);\n\n      if (cardinality === RegionCardinality.FULL_TABLE) {\n        return true;\n      }\n\n      if (cardinality === RegionCardinality.FULL_ROWS && Regions.intervalContainsIndex(region.rows, row)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if the regions contain a region that has FULL_TABLE cardinality\n   */\n\n\n  Regions.hasFullTable = function (regions) {\n    if (regions == null) {\n      return false;\n    }\n\n    for (var _i = 0, regions_3 = regions; _i < regions_3.length; _i++) {\n      var region = regions_3[_i];\n      var cardinality = Regions.getRegionCardinality(region);\n\n      if (cardinality === RegionCardinality.FULL_TABLE) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if the regions fully contain the query region.\n   */\n\n\n  Regions.containsRegion = function (regions, query) {\n    return Regions.overlapsRegion(regions, query, false);\n  };\n  /**\n   * Returns true if the regions at least partially overlap the query region.\n   */\n\n\n  Regions.overlapsRegion = function (regions, query, allowPartialOverlap) {\n    if (allowPartialOverlap === void 0) {\n      allowPartialOverlap = false;\n    }\n\n    var intervalCompareFn = allowPartialOverlap ? Regions.intervalOverlaps : Regions.intervalContains;\n\n    if (regions == null || query == null) {\n      return false;\n    }\n\n    for (var _i = 0, regions_4 = regions; _i < regions_4.length; _i++) {\n      var region = regions_4[_i];\n      var cardinality = Regions.getRegionCardinality(region);\n\n      switch (cardinality) {\n        case RegionCardinality.FULL_TABLE:\n          return true;\n\n        case RegionCardinality.FULL_COLUMNS:\n          if (intervalCompareFn(region.cols, query.cols)) {\n            return true;\n          }\n\n          continue;\n\n        case RegionCardinality.FULL_ROWS:\n          if (intervalCompareFn(region.rows, query.rows)) {\n            return true;\n          }\n\n          continue;\n\n        case RegionCardinality.CELLS:\n          if (intervalCompareFn(region.cols, query.cols) && intervalCompareFn(region.rows, query.rows)) {\n            return true;\n          }\n\n          continue;\n\n        default:\n          break;\n      }\n    }\n\n    return false;\n  };\n\n  Regions.eachUniqueFullColumn = function (regions, iteratee) {\n    if (regions == null || regions.length === 0 || iteratee == null) {\n      return;\n    }\n\n    var seen = {};\n    regions.forEach(function (region) {\n      if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_COLUMNS) {\n        var _a = region.cols,\n            start = _a[0],\n            end = _a[1];\n\n        for (var col = start; col <= end; col++) {\n          if (!seen[col]) {\n            seen[col] = true;\n            iteratee(col);\n          }\n        }\n      }\n    });\n  };\n\n  Regions.eachUniqueFullRow = function (regions, iteratee) {\n    if (regions == null || regions.length === 0 || iteratee == null) {\n      return;\n    }\n\n    var seen = {};\n    regions.forEach(function (region) {\n      if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_ROWS) {\n        var _a = region.rows,\n            start = _a[0],\n            end = _a[1];\n\n        for (var row = start; row <= end; row++) {\n          if (!seen[row]) {\n            seen[row] = true;\n            iteratee(row);\n          }\n        }\n      }\n    });\n  };\n  /**\n   * Using the supplied array of non-contiguous `IRegion`s, this method\n   * returns an ordered array of every unique cell that exists in those\n   * regions.\n   */\n\n\n  Regions.enumerateUniqueCells = function (regions, numRows, numCols) {\n    if (regions == null || regions.length === 0) {\n      return [];\n    }\n\n    var seen = {};\n    var list = [];\n\n    for (var _i = 0, regions_5 = regions; _i < regions_5.length; _i++) {\n      var region = regions_5[_i];\n      Regions.eachCellInRegion(region, numRows, numCols, function (row, col) {\n        // add to list if not seen\n        var key = row + \"-\" + col;\n\n        if (seen[key] !== true) {\n          seen[key] = true;\n          list.push([row, col]);\n        }\n      });\n    } // sort list by rows then columns\n\n\n    list.sort(Regions.rowFirstComparator);\n    return list;\n  };\n  /**\n   * Using the supplied region, returns an \"equivalent\" region of\n   * type CELLS that define the bounds of the given region\n   */\n\n\n  Regions.getCellRegionFromRegion = function (region, numRows, numCols) {\n    var regionCardinality = Regions.getRegionCardinality(region);\n\n    switch (regionCardinality) {\n      case RegionCardinality.FULL_TABLE:\n        return Regions.cell(0, 0, numRows - 1, numCols - 1);\n\n      case RegionCardinality.FULL_COLUMNS:\n        return Regions.cell(0, region.cols[0], numRows - 1, region.cols[1]);\n\n      case RegionCardinality.FULL_ROWS:\n        return Regions.cell(region.rows[0], 0, region.rows[1], numCols - 1);\n\n      case RegionCardinality.CELLS:\n        return Regions.cell(region.rows[0], region.cols[0], region.rows[1], region.cols[1]);\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Maps a dense array of cell coordinates to a sparse 2-dimensional array\n   * of cell values.\n   *\n   * We create a new 2-dimensional array representing the smallest single\n   * contiguous `IRegion` that contains all cells in the supplied array. We\n   * invoke the mapper callback only on the cells in the supplied coordinate\n   * array and store the result. Returns the resulting 2-dimensional array.\n   */\n\n\n  Regions.sparseMapCells = function (cells, mapper) {\n    var bounds = Regions.getBoundingRegion(cells);\n\n    if (bounds == null) {\n      return null;\n    }\n\n    var numRows = bounds.rows[1] + 1 - bounds.rows[0];\n    var numCols = bounds.cols[1] + 1 - bounds.cols[0];\n    var result = Utils.times(numRows, function () {\n      return new Array(numCols);\n    });\n    cells.forEach(function (_a) {\n      var row = _a[0],\n          col = _a[1];\n      result[row - bounds.rows[0]][col - bounds.cols[0]] = mapper(row, col);\n    });\n    return result;\n  };\n  /**\n   * Returns the smallest single contiguous `IRegion` that contains all cells in the\n   * supplied array.\n   */\n\n\n  Regions.getBoundingRegion = function (cells) {\n    var minRow;\n    var maxRow;\n    var minCol;\n    var maxCol;\n\n    for (var _i = 0, cells_1 = cells; _i < cells_1.length; _i++) {\n      var _a = cells_1[_i],\n          row = _a[0],\n          col = _a[1];\n      minRow = minRow == null || row < minRow ? row : minRow;\n      maxRow = maxRow == null || row > maxRow ? row : maxRow;\n      minCol = minCol == null || col < minCol ? col : minCol;\n      maxCol = maxCol == null || col > maxCol ? col : maxCol;\n    }\n\n    if (minRow == null) {\n      return null;\n    }\n\n    return {\n      cols: [minCol, maxCol],\n      rows: [minRow, maxRow]\n    };\n  };\n\n  Regions.isValid = function (region) {\n    if (region == null) {\n      return false;\n    }\n\n    if (region.rows != null && (region.rows[0] < 0 || region.rows[1] < 0)) {\n      return false;\n    }\n\n    if (region.cols != null && (region.cols[0] < 0 || region.cols[1] < 0)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  Regions.isRegionValidForTable = function (region, numRows, numCols) {\n    if (numRows === 0 || numCols === 0) {\n      return false;\n    } else if (region.rows != null && !intervalInRangeInclusive(region.rows, 0, numRows - 1)) {\n      return false;\n    } else if (region.cols != null && !intervalInRangeInclusive(region.cols, 0, numCols - 1)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  Regions.joinStyledRegionGroups = function (selectedRegions, otherRegions, focusedCell) {\n    var regionGroups = [];\n\n    if (otherRegions != null) {\n      regionGroups = regionGroups.concat(otherRegions);\n    }\n\n    if (selectedRegions != null && selectedRegions.length > 0) {\n      regionGroups.push({\n        className: Classes.TABLE_SELECTION_REGION,\n        regions: selectedRegions\n      });\n    }\n\n    if (focusedCell != null) {\n      regionGroups.push({\n        className: Classes.TABLE_FOCUS_REGION,\n        regions: [Regions.cell(focusedCell.row, focusedCell.col)]\n      });\n    }\n\n    return regionGroups;\n  };\n\n  Regions.regionsEqual = function (regionA, regionB) {\n    return Regions.intervalsEqual(regionA.rows, regionB.rows) && Regions.intervalsEqual(regionA.cols, regionB.cols);\n  };\n  /**\n   * Expands an old region to the minimal bounding region that also contains\n   * the new region. If the regions have different cardinalities, then the new\n   * region is returned. Useful for expanding a selected region on\n   * shift+click, for instance.\n   */\n\n\n  Regions.expandRegion = function (oldRegion, newRegion) {\n    var oldRegionCardinality = Regions.getRegionCardinality(oldRegion);\n    var newRegionCardinality = Regions.getRegionCardinality(newRegion);\n\n    if (newRegionCardinality !== oldRegionCardinality) {\n      return newRegion;\n    }\n\n    switch (newRegionCardinality) {\n      case RegionCardinality.FULL_ROWS:\n        {\n          var rowStart = Math.min(oldRegion.rows[0], newRegion.rows[0]);\n          var rowEnd = Math.max(oldRegion.rows[1], newRegion.rows[1]);\n          return Regions.row(rowStart, rowEnd);\n        }\n\n      case RegionCardinality.FULL_COLUMNS:\n        {\n          var colStart = Math.min(oldRegion.cols[0], newRegion.cols[0]);\n          var colEnd = Math.max(oldRegion.cols[1], newRegion.cols[1]);\n          return Regions.column(colStart, colEnd);\n        }\n\n      case RegionCardinality.CELLS:\n        {\n          var rowStart = Math.min(oldRegion.rows[0], newRegion.rows[0]);\n          var colStart = Math.min(oldRegion.cols[0], newRegion.cols[0]);\n          var rowEnd = Math.max(oldRegion.rows[1], newRegion.rows[1]);\n          var colEnd = Math.max(oldRegion.cols[1], newRegion.cols[1]);\n          return Regions.cell(rowStart, colStart, rowEnd, colEnd);\n        }\n\n      default:\n        return Regions.table();\n    }\n  };\n  /**\n   * Iterates over the cells within an `IRegion`, invoking the callback with\n   * each cell's coordinates.\n   */\n\n\n  Regions.eachCellInRegion = function (region, numRows, numCols, iteratee) {\n    var cardinality = Regions.getRegionCardinality(region);\n\n    switch (cardinality) {\n      case RegionCardinality.FULL_TABLE:\n        for (var row = 0; row < numRows; row++) {\n          for (var col = 0; col < numCols; col++) {\n            iteratee(row, col);\n          }\n        }\n\n        break;\n\n      case RegionCardinality.FULL_COLUMNS:\n        for (var row = 0; row < numRows; row++) {\n          for (var col = region.cols[0]; col <= region.cols[1]; col++) {\n            iteratee(row, col);\n          }\n        }\n\n        break;\n\n      case RegionCardinality.FULL_ROWS:\n        for (var row = region.rows[0]; row <= region.rows[1]; row++) {\n          for (var col = 0; col < numCols; col++) {\n            iteratee(row, col);\n          }\n        }\n\n        break;\n\n      case RegionCardinality.CELLS:\n        for (var row = region.rows[0]; row <= region.rows[1]; row++) {\n          for (var col = region.cols[0]; col <= region.cols[1]; col++) {\n            iteratee(row, col);\n          }\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  Regions.regionContains = function (regionA, regionB) {\n    // containsRegion expects an array of regions as the first param\n    return Regions.overlapsRegion([regionA], regionB, false);\n  };\n\n  Regions.intervalsEqual = function (ivalA, ivalB) {\n    if (ivalA == null) {\n      return ivalB == null;\n    } else if (ivalB == null) {\n      return false;\n    } else {\n      return ivalA[0] === ivalB[0] && ivalA[1] === ivalB[1];\n    }\n  };\n\n  Regions.intervalContainsIndex = function (interval, index) {\n    if (interval == null) {\n      return false;\n    }\n\n    return interval[0] <= index && interval[1] >= index;\n  };\n\n  Regions.intervalContains = function (ivalA, ivalB) {\n    if (ivalA == null || ivalB == null) {\n      return false;\n    }\n\n    return ivalA[0] <= ivalB[0] && ivalB[1] <= ivalA[1];\n  };\n\n  Regions.intervalOverlaps = function (ivalA, ivalB) {\n    if (ivalA == null || ivalB == null) {\n      return false;\n    }\n\n    if (ivalA[1] < ivalB[0] || ivalA[0] > ivalB[1]) {\n      return false;\n    }\n\n    return true;\n  };\n\n  Regions.rowFirstComparator = function (a, b) {\n    var rowDiff = a[0] - b[0];\n    return rowDiff === 0 ? a[1] - b[1] : rowDiff;\n  };\n\n  Regions.numericalComparator = function (a, b) {\n    return a - b;\n  };\n\n  Regions.normalizeInterval = function (coord, coord2) {\n    if (coord2 == null) {\n      coord2 = coord;\n    }\n\n    var interval = [coord, coord2];\n    interval.sort(Regions.numericalComparator);\n    return interval;\n  };\n\n  return Regions;\n}();\n\nexport { Regions };\n\nfunction intervalInRangeInclusive(interval, minInclusive, maxInclusive) {\n  return inRangeInclusive(interval[0], minInclusive, maxInclusive) && inRangeInclusive(interval[1], minInclusive, maxInclusive);\n}\n\nfunction inRangeInclusive(value, minInclusive, maxInclusive) {\n  return value >= minInclusive && value <= maxInclusive;\n}","map":null,"metadata":{},"sourceType":"module"}