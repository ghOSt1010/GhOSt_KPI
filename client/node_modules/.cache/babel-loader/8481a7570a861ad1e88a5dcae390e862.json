{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport * as Classes from \"../common/classes\";\nimport { Utils } from \"../common/index\";\nimport { Orientation } from \"../interactions/resizeHandle\";\nimport { RegionCardinality, Regions } from \"../regions\";\nimport { ColumnHeaderCell } from \"./columnHeaderCell\";\nimport { Header } from \"./header\";\n\nvar ColumnHeader =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ColumnHeader, _super);\n\n  function ColumnHeader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.wrapCells = function (cells) {\n      var _a = _this.props,\n          columnIndexStart = _a.columnIndexStart,\n          grid = _a.grid;\n      var tableWidth = grid.getRect().width;\n\n      var scrollLeftCorrection = _this.props.grid.getCumulativeWidthBefore(columnIndexStart);\n\n      var style = {\n        // only header cells in view will render, but we need to reposition them to stay in view\n        // as we scroll horizontally.\n        transform: \"translateX(\" + (scrollLeftCorrection || 0) + \"px)\",\n        // reduce the width to clamp the sliding window as we approach the final headers; otherwise,\n        // we'll have tons of useless whitespace at the end.\n        width: tableWidth - scrollLeftCorrection\n      };\n      var classes = classNames(Classes.TABLE_THEAD, Classes.TABLE_COLUMN_HEADER_TR); // add a wrapper set to the full-table width to ensure container styles stretch from the first\n      // cell all the way to the last\n\n      return React.createElement(\"div\", {\n        style: {\n          width: tableWidth\n        }\n      }, React.createElement(\"div\", {\n        style: style,\n        className: classes,\n        ref: _this.props.measurableElementRef\n      }, cells));\n    };\n\n    _this.convertPointToColumn = function (clientXOrY, useMidpoint) {\n      var locator = _this.props.locator;\n      return locator != null ? locator.convertPointToColumn(clientXOrY, useMidpoint) : null;\n    };\n\n    _this.getCellExtremaClasses = function (index, indexEnd) {\n      return _this.props.grid.getExtremaClasses(0, index, 1, indexEnd);\n    };\n\n    _this.getColumnWidth = function (index) {\n      return _this.props.grid.getColumnRect(index).width;\n    };\n\n    _this.getDragCoordinate = function (clientCoords) {\n      return clientCoords[0]; // x-coordinate\n    };\n\n    _this.getMouseCoordinate = function (event) {\n      return event.clientX;\n    };\n\n    _this.handleResizeEnd = function (index, size) {\n      _this.props.onResizeGuide(null);\n\n      _this.props.onColumnWidthChanged(index, size);\n    };\n\n    _this.handleResizeDoubleClick = function (index) {\n      var _a = _this.props,\n          minColumnWidth = _a.minColumnWidth,\n          maxColumnWidth = _a.maxColumnWidth;\n\n      var width = _this.props.locator.getWidestVisibleCellInColumn(index);\n\n      var clampedWidth = Utils.clamp(width, minColumnWidth, maxColumnWidth);\n\n      _this.props.onResizeGuide(null);\n\n      _this.props.onColumnWidthChanged(index, clampedWidth);\n    };\n\n    _this.handleSizeChanged = function (index, size) {\n      var rect = _this.props.grid.getColumnRect(index);\n\n      _this.props.onResizeGuide([rect.left + size]);\n    };\n\n    _this.isCellSelected = function (index) {\n      return Regions.hasFullColumn(_this.props.selectedRegions, index);\n    };\n\n    _this.isGhostIndex = function (index) {\n      return _this.props.grid.isGhostIndex(-1, index);\n    };\n\n    _this.renderGhostCell = function (index, extremaClasses) {\n      var _a = _this.props,\n          grid = _a.grid,\n          loading = _a.loading;\n      var rect = grid.getGhostCellRect(0, index);\n      var style = {\n        flexBasis: rect.width + \"px\",\n        width: rect.width + \"px\"\n      };\n      return React.createElement(ColumnHeaderCell, {\n        className: classNames(extremaClasses),\n        index: index,\n        key: Classes.columnIndexClass(index),\n        loading: loading,\n        style: style\n      });\n    };\n\n    _this.toRegion = function (index1, index2) {\n      return Regions.column(index1, index2);\n    };\n\n    return _this;\n  }\n\n  ColumnHeader.prototype.render = function () {\n    var _a = this.props,\n        // from IColumnHeaderProps\n    renderHeaderCell = _a.cellRenderer,\n        onColumnWidthChanged = _a.onColumnWidthChanged,\n        // from IColumnWidths\n    minSize = _a.minColumnWidth,\n        maxSize = _a.maxColumnWidth,\n        defaultColumnWidth = _a.defaultColumnWidth,\n        // from IColumnIndices\n    indexStart = _a.columnIndexStart,\n        indexEnd = _a.columnIndexEnd,\n        // from IHeaderProps\n    spreadableProps = tslib_1.__rest(_a, [\"cellRenderer\", \"onColumnWidthChanged\", \"minColumnWidth\", \"maxColumnWidth\", \"defaultColumnWidth\", \"columnIndexStart\", \"columnIndexEnd\"]);\n\n    return React.createElement(Header, tslib_1.__assign({\n      convertPointToIndex: this.convertPointToColumn,\n      fullRegionCardinality: RegionCardinality.FULL_COLUMNS,\n      getCellExtremaClasses: this.getCellExtremaClasses,\n      getCellIndexClass: Classes.columnCellIndexClass,\n      getCellSize: this.getColumnWidth,\n      getDragCoordinate: this.getDragCoordinate,\n      getIndexClass: Classes.columnIndexClass,\n      getMouseCoordinate: this.getMouseCoordinate,\n      ghostCellRenderer: this.renderGhostCell,\n      handleResizeDoubleClick: this.handleResizeDoubleClick,\n      handleResizeEnd: this.handleResizeEnd,\n      handleSizeChanged: this.handleSizeChanged,\n      headerCellIsReorderablePropName: \"enableColumnReordering\",\n      headerCellIsSelectedPropName: \"isColumnSelected\",\n      headerCellRenderer: renderHeaderCell,\n      indexEnd: indexEnd,\n      indexStart: indexStart,\n      isCellSelected: this.isCellSelected,\n      isGhostIndex: this.isGhostIndex,\n      maxSize: maxSize,\n      minSize: minSize,\n      resizeOrientation: Orientation.VERTICAL,\n      selectedRegions: [],\n      toRegion: this.toRegion,\n      wrapCells: this.wrapCells\n    }, spreadableProps));\n  };\n\n  ColumnHeader.defaultProps = {\n    isReorderable: false,\n    isResizable: true,\n    loading: false\n  };\n  return ColumnHeader;\n}(React.Component);\n\nexport { ColumnHeader };","map":null,"metadata":{},"sourceType":"module"}