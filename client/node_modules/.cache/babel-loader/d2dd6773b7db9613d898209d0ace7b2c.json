{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { DISPLAYNAME_PREFIX, Icon, Popover, Position } from \"@blueprintjs/core\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport * as Classes from \"../../common/classes\";\nimport { Utils } from \"../../common/utils\";\nimport { Locator } from \"../../locator\"; // amount in pixels that the content div width changes when truncated vs when\n// not truncated. Note: could be modified by styles\n// Note 2: this doesn't come from the width of the popover element, but the \"right\" style\n// on the div, which comes from styles\n\nvar CONTENT_DIV_WIDTH_DELTA = 25;\nexport var TruncatedPopoverMode;\n\n(function (TruncatedPopoverMode) {\n  TruncatedPopoverMode[\"ALWAYS\"] = \"always\";\n  TruncatedPopoverMode[\"NEVER\"] = \"never\";\n  TruncatedPopoverMode[\"WHEN_TRUNCATED\"] = \"when-truncated\";\n  TruncatedPopoverMode[\"WHEN_TRUNCATED_APPROX\"] = \"when-truncated-approx\";\n})(TruncatedPopoverMode || (TruncatedPopoverMode = {}));\n\nvar TruncatedFormat =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(TruncatedFormat, _super);\n\n  function TruncatedFormat() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      isPopoverOpen: false,\n      isTruncated: false\n    };\n\n    _this.handleContentDivRef = function (ref) {\n      return _this.contentDiv = ref;\n    };\n\n    _this.handlePopoverOpen = function () {\n      _this.setState({\n        isPopoverOpen: true\n      });\n    };\n\n    _this.handlePopoverClose = function () {\n      _this.setState({\n        isPopoverOpen: false\n      });\n    };\n\n    return _this;\n  }\n\n  TruncatedFormat.prototype.componentDidMount = function () {\n    this.setTruncationState();\n  };\n\n  TruncatedFormat.prototype.componentDidUpdate = function () {\n    this.setTruncationState();\n  };\n\n  TruncatedFormat.prototype.render = function () {\n    var _a = this.props,\n        children = _a.children,\n        detectTruncation = _a.detectTruncation,\n        truncateLength = _a.truncateLength,\n        truncationSuffix = _a.truncationSuffix;\n    var content = \"\" + children;\n    var cellContent = content;\n\n    if (!detectTruncation && truncateLength > 0 && cellContent.length > truncateLength) {\n      cellContent = cellContent.substring(0, truncateLength) + truncationSuffix;\n    }\n\n    if (this.shouldShowPopover(content)) {\n      var className = classNames(this.props.className, Classes.TABLE_TRUNCATED_FORMAT);\n      return React.createElement(\"div\", {\n        className: className\n      }, React.createElement(\"div\", {\n        className: Classes.TABLE_TRUNCATED_VALUE,\n        ref: this.handleContentDivRef\n      }, cellContent), this.renderPopover());\n    } else {\n      var className = classNames(this.props.className, Classes.TABLE_TRUNCATED_FORMAT_TEXT);\n      return React.createElement(\"div\", {\n        className: className,\n        ref: this.handleContentDivRef\n      }, cellContent);\n    }\n  };\n\n  TruncatedFormat.prototype.renderPopover = function () {\n    var _a = this.props,\n        children = _a.children,\n        preformatted = _a.preformatted; // `<Popover>` will always check the content's position on update\n    // regardless if it is open or not. This negatively affects perf due to\n    // layout thrashing. So instead we manage the popover state ourselves\n    // and mimic its popover target\n\n    if (this.state.isPopoverOpen) {\n      var popoverClasses = classNames(Classes.TABLE_TRUNCATED_POPOVER, preformatted ? Classes.TABLE_POPOVER_WHITESPACE_PRE : Classes.TABLE_POPOVER_WHITESPACE_NORMAL);\n      var popoverContent = React.createElement(\"div\", {\n        className: popoverClasses\n      }, children);\n      return React.createElement(Popover, {\n        className: Classes.TABLE_TRUNCATED_POPOVER_TARGET,\n        modifiers: {\n          preventOverflow: {\n            boundariesElement: \"window\"\n          }\n        },\n        content: popoverContent,\n        position: Position.BOTTOM,\n        isOpen: true,\n        onClose: this.handlePopoverClose\n      }, React.createElement(Icon, {\n        icon: \"more\"\n      }));\n    } else {\n      // NOTE: This structure matches what `<Popover>` does internally. If\n      // `<Popover>` changes, this must be updated.\n      return React.createElement(\"span\", {\n        className: Classes.TABLE_TRUNCATED_POPOVER_TARGET,\n        onClick: this.handlePopoverOpen\n      }, React.createElement(Icon, {\n        icon: \"more\"\n      }));\n    }\n  };\n\n  TruncatedFormat.prototype.shouldShowPopover = function (content) {\n    var _a = this.props,\n        detectTruncation = _a.detectTruncation,\n        measureByApproxOptions = _a.measureByApproxOptions,\n        showPopover = _a.showPopover,\n        truncateLength = _a.truncateLength;\n\n    switch (showPopover) {\n      case TruncatedPopoverMode.ALWAYS:\n        return true;\n\n      case TruncatedPopoverMode.NEVER:\n        return false;\n\n      case TruncatedPopoverMode.WHEN_TRUNCATED:\n        return detectTruncation ? this.state.isTruncated : truncateLength > 0 && content.length > truncateLength;\n\n      case TruncatedPopoverMode.WHEN_TRUNCATED_APPROX:\n        if (!detectTruncation) {\n          return truncateLength > 0 && content.length > truncateLength;\n        }\n\n        if (this.props.parentCellHeight == null || this.props.parentCellWidth == null) {\n          return false;\n        }\n\n        var approximateCharWidth = measureByApproxOptions.approximateCharWidth,\n            approximateLineHeight = measureByApproxOptions.approximateLineHeight,\n            cellHorizontalPadding = measureByApproxOptions.cellHorizontalPadding,\n            numBufferLines = measureByApproxOptions.numBufferLines;\n        var cellWidth = this.props.parentCellWidth;\n        var approxCellHeight = Utils.getApproxCellHeight(content, cellWidth, approximateCharWidth, approximateLineHeight, cellHorizontalPadding, numBufferLines);\n        var shouldTruncate = approxCellHeight > this.props.parentCellHeight;\n        return shouldTruncate;\n\n      default:\n        return false;\n    }\n  };\n\n  TruncatedFormat.prototype.setTruncationState = function () {\n    if (!this.props.detectTruncation || this.props.showPopover !== TruncatedPopoverMode.WHEN_TRUNCATED) {\n      return;\n    }\n\n    if (this.contentDiv === undefined) {\n      this.setState({\n        isTruncated: false\n      });\n      return;\n    }\n\n    var isTruncated = this.state.isTruncated; // take all measurements at once to avoid excessive DOM reflows.\n\n    var _a = this.contentDiv,\n        containerHeight = _a.clientHeight,\n        containerWidth = _a.clientWidth,\n        actualContentHeight = _a.scrollHeight,\n        contentWidth = _a.scrollWidth; // if the content is truncated, then a popover handle will be present as a\n    // sibling of the content. we don't want to consider that handle when\n    // calculating the width of the actual content, so subtract it.\n\n    var actualContentWidth = isTruncated ? contentWidth - CONTENT_DIV_WIDTH_DELTA : contentWidth; // we of course truncate the content if it doesn't fit in the container. but we\n    // also aggressively truncate if they're the same size with truncation enabled;\n    // this addresses browser-crashing stack-overflow bugs at various zoom levels.\n    // (see: https://github.com/palantir/blueprint/pull/1519)\n\n    var shouldTruncate = isTruncated && actualContentWidth === containerWidth || actualContentWidth > containerWidth || actualContentHeight > containerHeight;\n    this.setState({\n      isTruncated: shouldTruncate\n    });\n  };\n\n  TruncatedFormat.displayName = DISPLAYNAME_PREFIX + \".TruncatedFormat\";\n  TruncatedFormat.defaultProps = {\n    detectTruncation: false,\n    measureByApproxOptions: {\n      approximateCharWidth: 8,\n      approximateLineHeight: 18,\n      cellHorizontalPadding: 2 * Locator.CELL_HORIZONTAL_PADDING,\n      numBufferLines: 0\n    },\n    preformatted: false,\n    showPopover: TruncatedPopoverMode.WHEN_TRUNCATED,\n    truncateLength: 2000,\n    truncationSuffix: \"...\"\n  };\n  return TruncatedFormat;\n}(React.PureComponent);\n\nexport { TruncatedFormat };","map":null,"metadata":{},"sourceType":"module"}