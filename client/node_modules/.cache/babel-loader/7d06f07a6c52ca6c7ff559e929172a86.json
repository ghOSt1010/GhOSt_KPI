{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { RegionCardinality, Regions } from \"../../regions\";\nimport * as Errors from \"../errors\";\n/**\n * Returns the `focusedSelectionIndex` if both the focused cell and that\n * property are defined, or the last index of `selectedRegions` otherwise. If\n * `selectedRegions` is empty, the function always returns `undefined`.\n */\n\nexport function getFocusedOrLastSelectedIndex(selectedRegions, focusedCell) {\n  if (selectedRegions.length === 0) {\n    return undefined;\n  } else if (focusedCell != null) {\n    return focusedCell.focusSelectionIndex;\n  } else {\n    return selectedRegions.length - 1;\n  }\n}\n/**\n * Returns the proper focused cell for the given set of initial conditions.\n */\n\nexport function getInitialFocusedCell(enableFocusedCell, focusedCellFromProps, focusedCellFromState, selectedRegions) {\n  if (!enableFocusedCell) {\n    return undefined;\n  } else if (focusedCellFromProps != null) {\n    // controlled mode\n    return focusedCellFromProps;\n  } else if (focusedCellFromState != null) {\n    // use the current focused cell from state\n    return focusedCellFromState;\n  } else if (selectedRegions.length > 0) {\n    // focus the top-left cell of the last selection\n    var lastIndex = selectedRegions.length - 1;\n    return tslib_1.__assign({}, Regions.getFocusCellCoordinatesFromRegion(selectedRegions[lastIndex]), {\n      focusSelectionIndex: lastIndex\n    });\n  } else {\n    // focus the top-left cell of the table\n    return {\n      col: 0,\n      row: 0,\n      focusSelectionIndex: 0\n    };\n  }\n}\n/**\n * Returns `true` if the focused cell is located along the top boundary of the\n * provided region, or `false` otherwise.\n */\n\nexport function isFocusedCellAtRegionTop(region, focusedCell) {\n  return region.rows != null && focusedCell.row === region.rows[0];\n}\n/**\n * Returns `true` if the focused cell is located along the bottom boundary of\n * the provided region, or `false` otherwise.\n */\n\nexport function isFocusedCellAtRegionBottom(region, focusedCell) {\n  return region.rows != null && focusedCell.row === region.rows[1];\n}\n/**\n * Returns `true` if the focused cell is located along the left boundary of the\n * provided region, or `false` otherwise.\n */\n\nexport function isFocusedCellAtRegionLeft(region, focusedCell) {\n  return region.cols != null && focusedCell.col === region.cols[0];\n}\n/**\n * Returns `true` if the focused cell is located along the right boundary of the\n * provided region, or `false` otherwise.\n */\n\nexport function isFocusedCellAtRegionRight(region, focusedCell) {\n  return region.cols != null && focusedCell.col === region.cols[1];\n}\n/**\n * Returns a new cell-coordinates object that includes a focusSelectionIndex property.\n * The returned object will have the proper IFocusedCellCoordinates type.\n */\n\nexport function toFullCoordinates(cellCoords, focusSelectionIndex) {\n  if (focusSelectionIndex === void 0) {\n    focusSelectionIndex = 0;\n  }\n\n  return tslib_1.__assign({}, cellCoords, {\n    focusSelectionIndex: focusSelectionIndex\n  });\n}\n/**\n * Expands an existing region to new region based on the current focused cell.\n * The focused cell is an invariant and should not move as a result of this\n * operation. This function is used, for instance, to expand a selected region\n * on shift+click.\n */\n\nexport function expandFocusedRegion(focusedCell, newRegion) {\n  switch (Regions.getRegionCardinality(newRegion)) {\n    case RegionCardinality.FULL_COLUMNS:\n      {\n        var _a = getExpandedRegionIndices(focusedCell, newRegion, \"col\", \"cols\"),\n            indexStart = _a[0],\n            indexEnd = _a[1];\n\n        return Regions.column(indexStart, indexEnd);\n      }\n\n    case RegionCardinality.FULL_ROWS:\n      {\n        var _b = getExpandedRegionIndices(focusedCell, newRegion, \"row\", \"rows\"),\n            indexStart = _b[0],\n            indexEnd = _b[1];\n\n        return Regions.row(indexStart, indexEnd);\n      }\n\n    case RegionCardinality.CELLS:\n      var _c = getExpandedRegionIndices(focusedCell, newRegion, \"row\", \"rows\"),\n          rowIndexStart = _c[0],\n          rowIndexEnd = _c[1];\n\n      var _d = getExpandedRegionIndices(focusedCell, newRegion, \"col\", \"cols\"),\n          colIndexStart = _d[0],\n          colIndexEnd = _d[1];\n\n      return Regions.cell(rowIndexStart, colIndexStart, rowIndexEnd, colIndexEnd);\n\n    default:\n      // i.e. `case RegionCardinality.FULL_TABLE:`\n      return Regions.table();\n  }\n}\n\nfunction getExpandedRegionIndices(focusedCell, newRegion, focusedCellDimension, regionDimension) {\n  var sourceIndex = focusedCell[focusedCellDimension];\n  var _a = newRegion[regionDimension],\n      destinationIndex = _a[0],\n      destinationIndexEnd = _a[1];\n\n  if (destinationIndex !== destinationIndexEnd) {\n    if (regionDimension === \"rows\") {\n      throw new Error(Errors.TABLE_EXPAND_FOCUSED_REGION_MULTI_ROW_REGION);\n    } else if (regionDimension === \"cols\") {\n      throw new Error(Errors.TABLE_EXPAND_FOCUSED_REGION_MULTI_COLUMN_REGION);\n    }\n  }\n\n  return sourceIndex <= destinationIndex ? [sourceIndex, destinationIndex] : [destinationIndex, sourceIndex];\n}","map":null,"metadata":{},"sourceType":"module"}