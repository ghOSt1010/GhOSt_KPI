{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { AbstractComponent2, Utils as CoreUtils } from \"@blueprintjs/core\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { emptyCellRenderer } from \"./cell/cell\";\nimport { Batcher } from \"./common/batcher\";\nimport * as Classes from \"./common/classes\";\nimport { Rect } from \"./common/rect\";\nimport { RenderMode } from \"./common/renderMode\";\nvar SHALLOW_COMPARE_BLACKLIST = [\"viewportRect\"];\n/**\n * We don't want to reset the batcher when this set of keys changes. Any other\n * changes should reset the batcher's internal cache.\n */\n\nvar BATCHER_RESET_PROP_KEYS_BLACKLIST = [\"columnIndexEnd\", \"columnIndexStart\", \"rowIndexEnd\", \"rowIndexStart\"];\n\nvar TableBodyCells =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(TableBodyCells, _super);\n\n  function TableBodyCells() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.batcher = new Batcher(); // Cell renderers\n    // ==============\n\n    _this.renderNewCell = function (rowIndex, columnIndex) {\n      var _a = _this.props,\n          columnIndexEnd = _a.columnIndexEnd,\n          grid = _a.grid,\n          rowIndexEnd = _a.rowIndexEnd;\n      var extremaClasses = grid.getExtremaClasses(rowIndex, columnIndex, rowIndexEnd, columnIndexEnd);\n      var isGhost = grid.isGhostIndex(rowIndex, columnIndex);\n      return _this.renderCell(rowIndex, columnIndex, extremaClasses, isGhost);\n    };\n\n    _this.renderCell = function (rowIndex, columnIndex, extremaClasses, isGhost) {\n      var _a;\n\n      var _b = _this.props,\n          cellRenderer = _b.cellRenderer,\n          focusedCell = _b.focusedCell,\n          loading = _b.loading,\n          grid = _b.grid;\n      var baseCell = isGhost ? emptyCellRenderer() : cellRenderer(rowIndex, columnIndex); // cellRenderer still may return null\n\n      baseCell = baseCell == null ? emptyCellRenderer() : baseCell;\n      var className = classNames(cellClassNames(rowIndex, columnIndex), extremaClasses, (_a = {}, _a[Classes.TABLE_CELL_GHOST] = isGhost, _a[Classes.TABLE_CELL_LEDGER_ODD] = rowIndex % 2 === 1, _a[Classes.TABLE_CELL_LEDGER_EVEN] = rowIndex % 2 === 0, _a), baseCell.props.className);\n      var key = TableBodyCells.cellReactKey(rowIndex, columnIndex);\n      var rect = isGhost ? grid.getGhostCellRect(rowIndex, columnIndex) : grid.getCellRect(rowIndex, columnIndex);\n      var cellLoading = baseCell.props.loading != null ? baseCell.props.loading : loading;\n\n      var style = tslib_1.__assign({}, baseCell.props.style, Rect.style(rect));\n\n      var isFocused = focusedCell != null && focusedCell.row === rowIndex && focusedCell.col === columnIndex;\n      return React.cloneElement(baseCell, {\n        className: className,\n        key: key,\n        isFocused: isFocused,\n        loading: cellLoading,\n        style: style\n      });\n    }; // Other\n    // =====\n\n\n    _this.didViewportRectChange = function (nextViewportRect, currViewportRect) {\n      if (nextViewportRect == null && currViewportRect == null) {\n        return false;\n      } else if (nextViewportRect == null || currViewportRect == null) {\n        return true;\n      } else {\n        return !nextViewportRect.equals(currViewportRect);\n      }\n    };\n\n    return _this;\n  }\n\n  TableBodyCells.cellReactKey = function (rowIndex, columnIndex) {\n    return \"cell-\" + rowIndex + \"-\" + columnIndex;\n  };\n\n  TableBodyCells.prototype.componentDidMount = function () {\n    this.maybeInvokeOnCompleteRender();\n  };\n\n  TableBodyCells.prototype.shouldComponentUpdate = function (nextProps) {\n    return !CoreUtils.shallowCompareKeys(nextProps, this.props, {\n      exclude: SHALLOW_COMPARE_BLACKLIST\n    }) || // \"viewportRect\" is not a plain object, so we can't just deep\n    // compare; we need custom logic.\n    this.didViewportRectChange(nextProps.viewportRect, this.props.viewportRect);\n  };\n\n  TableBodyCells.prototype.componentDidUpdate = function (prevProps) {\n    var shouldResetBatcher = !CoreUtils.shallowCompareKeys(prevProps, this.props, {\n      exclude: BATCHER_RESET_PROP_KEYS_BLACKLIST\n    });\n\n    if (shouldResetBatcher) {\n      this.batcher.reset();\n    }\n\n    this.maybeInvokeOnCompleteRender();\n  };\n\n  TableBodyCells.prototype.componentWillUnmount = function () {\n    this.batcher.cancelOutstandingCallback();\n  };\n\n  TableBodyCells.prototype.render = function () {\n    var renderMode = this.props.renderMode;\n    var cells = renderMode === RenderMode.BATCH ? this.renderBatchedCells() : this.renderAllCells();\n    return React.createElement(\"div\", {\n      className: Classes.TABLE_BODY_CELLS\n    }, cells);\n  }; // Render modes\n  // ============\n\n\n  TableBodyCells.prototype.renderBatchedCells = function () {\n    var _this = this;\n\n    var _a = this.props,\n        columnIndexEnd = _a.columnIndexEnd,\n        columnIndexStart = _a.columnIndexStart,\n        rowIndexEnd = _a.rowIndexEnd,\n        rowIndexStart = _a.rowIndexStart; // render cells in batches\n\n    this.batcher.startNewBatch();\n\n    for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n      for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n        this.batcher.addArgsToBatch(rowIndex, columnIndex);\n      }\n    }\n\n    this.batcher.removeOldAddNew(this.renderNewCell);\n\n    if (!this.batcher.isDone()) {\n      this.batcher.idleCallback(function () {\n        return _this.forceUpdate();\n      });\n    }\n\n    return this.batcher.getList();\n  };\n\n  TableBodyCells.prototype.renderAllCells = function () {\n    var _a = this.props,\n        columnIndexEnd = _a.columnIndexEnd,\n        columnIndexStart = _a.columnIndexStart,\n        rowIndexEnd = _a.rowIndexEnd,\n        rowIndexStart = _a.rowIndexStart;\n    var cells = [];\n    var cellsArgs = [];\n\n    for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n      for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n        cells.push(this.renderNewCell(rowIndex, columnIndex));\n        cellsArgs.push([rowIndex, columnIndex]);\n      }\n    } // pretend we did an entire rendering pass using the batcher. that way,\n    // if we switch from `RenderMode.NONE` to `RenderMode.BATCH`, we don't\n    // have to re-paint every cell still in view.\n\n\n    this.batcher.setList(cellsArgs, cells);\n    return cells;\n  }; // Callbacks\n  // =========\n\n\n  TableBodyCells.prototype.maybeInvokeOnCompleteRender = function () {\n    var _a = this.props,\n        onCompleteRender = _a.onCompleteRender,\n        renderMode = _a.renderMode;\n\n    if (renderMode === RenderMode.NONE || renderMode === RenderMode.BATCH && this.batcher.isDone()) {\n      CoreUtils.safeInvoke(onCompleteRender);\n    }\n  };\n\n  TableBodyCells.defaultProps = {\n    renderMode: RenderMode.BATCH\n  };\n  return TableBodyCells;\n}(AbstractComponent2);\n\nexport { TableBodyCells };\n/**\n * Returns the array of class names that must be applied to each table\n * cell so that we can locate any cell based on its coordinate.\n */\n\nexport function cellClassNames(rowIndex, columnIndex) {\n  return [Classes.rowCellIndexClass(rowIndex), Classes.columnCellIndexClass(columnIndex)];\n}","map":null,"metadata":{},"sourceType":"module"}